"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7105],{29480:e=>{e.exports=JSON.parse('{"functions":[{"name":"schedule","desc":" \\nSchedules the given callback to be run during the given run service event. This is useful because\\nthis utility sets up all these events **once** and registers the given scheduledCallbacksData to be called during\\neach event\'s invocation point - this prevents you from initializing many different types of RunService\\nevents.\\n\\n```lua\\nschedulerUtil.schedule(schedulerUtil.RunServiceEvent.Stepped, \\"PerformPhyicsUpdate\\" function(_, deltaTime: number)\\n\\t-- Perform physics update here\\nend)\\n```\\n\\nAdditionally, this method also returns a cleanup function will call unschedule the scheduled event through [schedulerUtil.unschedule].\\n\\n:::warning Yielding is not allowed\\nScheduled callbacks **should** never yield. If they do so, other scheduled callbacks will not be able to run and the utility\\noffers no protection against this due to performance related issues.\\n:::\\n\\n:::tip Automatic memory & performance profiling\\nA debug profile is automatically created for the scheduled callback using `debug.profilebegin(callbackIdentifier)`, \\nwhich will allow you to easily  monitor the performance of individual scheduled callback. Additionally, a debug memory\\ncategory is also setup for the given callback using `debug.setmemorycategory(callbackIdentifier)`.\\n\\nThis utility automatically outputs a warning message in the console **every 10 seconds** if a given scheduled callback takes a bit too\\nlong to finish running - so you can also pass in an optional 4th argument, `maxExpectedCallbackRunTime` to have the system know how long\\nthe given scheduled callback should be expected to finish running.\\n:::","params":[{"name":"runServiceEventName","desc":"","lua_type":"string"},{"name":"callbackIdentifier","desc":"","lua_type":"string"},{"name":"callback","desc":"","lua_type":"(...any) -> ()"},{"name":"maxExpectedCallbackRunTime","desc":"","lua_type":"number?\\r\\n"}],"returns":[{"desc":"","lua_type":"() -> ()\\r\\n"}],"function_type":"static","source":{"line":54,"path":"src/schedulerUtil/init.luau"}},{"name":"unschedule","desc":" \\nDeschedules the given RunService event bound callback.","params":[{"name":"runServiceEventName","desc":"","lua_type":"string"},{"name":"callbackIdentifier","desc":"","lua_type":"string"}],"returns":[],"function_type":"static","source":{"line":91,"path":"src/schedulerUtil/init.luau"}}],"properties":[],"types":[],"name":"schedulerUtil","desc":" \\n\\nA simple utility module for scheduling [RunService](https://create.roblox.com/docs/reference/engine/classes/RunService) events with minimal performance impacts\\nand with automatic performance profiling.","source":{"line":7,"path":"src/schedulerUtil/init.luau"}}')}}]);