"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2768],{43007:e=>{e.exports=JSON.parse('{"functions":[{"name":"new","desc":"A constructor method that creates a new property object, with `initialValue` as the current value\\nof the property.","params":[{"name":"initialValue","desc":"","lua_type":"T?"}],"returns":[{"desc":"","lua_type":"Property"}],"function_type":"static","source":{"line":50,"path":"src/Property/init.luau"}},{"name":"is","desc":"A method that returns a boolean indicating if `self` is a property or not.","params":[{"name":"self","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"boolean\\r\\n"}],"function_type":"static","source":{"line":69,"path":"src/Property/init.luau"}},{"name":"bindToRobloxProperty","desc":"Binds the property to a property of the given Roblox instance. When the instance is destroyed,\\nthe property is automatically destroyed as well.\\n\\n```lua\\nlocal property = Property.new()\\nproperty:bindToRobloxProperty(workspace.Baseplate, \\"Transparency\\")\\n\\nproperty.onUpdate:Connect(function(newTransparency, oldTransparency)\\n\\tprint(newTransparency, oldTransparency) --\x3e 1, 0\\nend)\\n\\nprint(property:get()) --\x3e 0\\n\\nworkspace.Baseplate.Transparency = 1\\n\\n-- Deferred signal behavior: (Roblox instance-signals are not immediately fired)\\nprint(property.onUpdate:Wait()) --\x3e 1\\n```","params":[{"name":"instance","desc":"","lua_type":"Instance"},{"name":"property","desc":"","lua_type":"string"}],"returns":[],"function_type":"method","source":{"line":94,"path":"src/Property/init.luau"}},{"name":"bindToInstanceAttribute","desc":"Binds the property to an attribute of the given Roblox instance. When the instance is destroyed,\\nthe property is automatically destroyed as well.\\n\\n```lua\\nlocal property = Property.new()\\nproperty:bindToInstanceAttribute(workspace.Baseplate, \\"SomeAttribute\\")\\n\\nprint(property:get()) --\x3e nil\\n\\nworkspace.Baseplate:SetAttribute(\\"SomeAttribute\\", 5)\\n\\nprint(property:get()) --\x3e 5\\n```","params":[{"name":"instance","desc":"","lua_type":"Instance"},{"name":"attribute","desc":"","lua_type":"string"}],"returns":[],"function_type":"method","source":{"line":118,"path":"src/Property/init.luau"}},{"name":"bindToInstance","desc":"Binds the property to an instance so that once the instance is destroyed,\\nthe property will be destroyed too.\\n\\n```lua\\nlocal property = Property.new()\\nproperty:bindToInstance(workspace.Baseplate)\\n\\n print(Property.is(property)) --\x3e true\\n\\nworkspace.Baseplate:Destroy()\\n\\ntask.wait() -- Deferred signal behavior\\n\\nprint(Property.is(property)) --\x3e false\\n```","params":[{"name":"instance","desc":"","lua_type":"Instance"}],"returns":[],"function_type":"method","source":{"line":144,"path":"src/Property/init.luau"}},{"name":"set","desc":"Sets the value of the property to `value`, if this new value isn\'t the same as the previous value. ","params":[{"name":"value","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","source":{"line":154,"path":"src/Property/init.luau"}},{"name":"observe","desc":"Observes the value of the property. \\n\\n```lua\\nproperty:observe(function(newValue, oldValue)\\n\\nend)\\n```","params":[{"name":"callback","desc":"","lua_type":"(newValue: any, oldValue: any) -> ()"}],"returns":[],"function_type":"method","source":{"line":175,"path":"src/Property/init.luau"}},{"name":"valuePromise","desc":"Returns a promise which is resolved with a non-nil value of the property, given that\\n`valuePredicate` is not specified.\\n\\n```lua\\nlocal property = Property.new()\\n\\nproperty:valuePromise():andThen(function(value)\\n\\tprint(value) --\x3e 2\\nend)\\n\\nproperty:set(2)\\n```\\n\\n`valuePredicate` (an optional predicate), allows you to filter out values:\\n\\n```lua\\nlocal property = Property.new()\\n\\nproperty:valuePromise(function(newValue, oldValue) \\n\\tprint(newValue, oldValue)\\n\\treturn oldValue == \\"no\\"\\nend):andThen(function(value)\\n\\tprint(value) --\x3e \\"yes\\"\\nend)\\n\\nproperty:set(\\"no\\") \\nproperty:set(\\"yes\\") \\n\\n-- Output:\\n-- \\"no\\", nil\\n-- \\"yes\\", \\"no\\"\\n-- \\"yes\\"\\n```","params":[{"name":"valuePredicate","desc":"","lua_type":"((newValue: any, oldValue: any) -> boolean)?"}],"returns":[],"function_type":"method","source":{"line":222,"path":"src/Property/init.luau"}},{"name":"forceSet","desc":"Works the same as [Property:set] except that tables aren\'t checked for equality, for e.g:\\n\\n```lua\\nlocal property = Property.new()\\n\\nproperty.onUpdate:Connect(function(newVal)\\n\\twarn(newVal) --\x3e {1}\\nend)\\n\\nlocal t = {1}\\n\\nproperty:forceSet(t) --\x3e Fires off the .onUpdate signal (expected)\\n\\n-- This ought to not fire off the signal, but the previous and new value\\n-- aren\'t checked for equality since they\'re both tables)\\nproperty:forceSet(t) \\n\\n-- Fires off the .onUpdate signal (expected as a number ~= table) \\nproperty:forceSet(1) \\n\\n-- Does NOT fire off the .onUpdate signal, since the previous value \\n-- (a number, not a table) and the new value (a number, not a table) are the\\n-- same!\\nproperty:forceSet(1) \\n```","params":[{"name":"value","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","tags":["Property Instance"],"source":{"line":271,"path":"src/Property/init.luau"}},{"name":"bulkSet","desc":"Works almost the same as [Property:set], but never fires off the [Property.onUpdate] signal.","params":[{"name":"value","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","source":{"line":286,"path":"src/Property/init.luau"}},{"name":"get","desc":"Returns a shallow copy of the current value of the property.\\n\\n```lua\\nlocal property = Property.new()\\n\\nlocal t = {}\\nproperty:set(t)\\nprint(property:get() == t) --\x3e false\\n```","params":[],"returns":[{"desc":"","lua_type":"any"}],"function_type":"method","source":{"line":303,"path":"src/Property/init.luau"}},{"name":"destroy","desc":"Destroys the property and renders it unusable.","params":[],"returns":[],"function_type":"method","source":{"line":311,"path":"src/Property/init.luau"}}],"properties":[{"name":"onUpdate","desc":" \\n\\nA [signal](https://sleitnick.github.io/RbxUtil/api/Signal/) which is fired whenever the value of the property is \\nset to a new one. The signal is only passed the new value as the only argument.","lua_type":"Signal <newValue: any, oldValue: any>","tags":["Signal","Property Instance"],"readonly":true,"source":{"line":28,"path":"src/Property/init.luau"}}],"types":[{"name":"Property","desc":" ","lua_type":"Property<T>","source":{"line":33,"path":"src/Property/init.luau"}}],"name":"Property","desc":" \\n\\nA class for wrapping values around setters and getters. A property in layman\'s terms is simply an object which contains some value.\\n \\n```lua\\nlocal property = Property.new(5)\\nprint(property:get()) --\x3e 5\\n\\nproperty.onUpdate:Connect(function(newValue, oldValue)\\n\\tprint(newValue, oldValue) --\x3e 10, 5\\nend)\\n\\nproperty:set(10) \\n```","source":{"line":17,"path":"src/Property/init.luau"}}')}}]);