"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8924],{54832:e=>{e.exports=JSON.parse('{"functions":[{"name":"new","desc":"Creates and returns a new network object of `name`.\\n\\n```lua\\n-- Server:\\nlocal network = NetworkServer.new(\\"Test\\")\\nnetwork:append(\\"key\\", \\"some value\\")\\nnetwork:dispatch(game:GetService(\\"ReplicatedStorage\\"))\\n\\n-- Client:\\nlocal network = network.Client.fromParent(\\"Test\\", game:GetService(\\"ReplicatedStorage\\")):expect()\\nprint(network.key) --\x3e \\"some value\\"\\n```\\n\\n- If the 2nd parameter `middleware` is not specified, then it will default to [DefaultNetworkServerMiddleware] instead.\\n- If the 3rd parameter `config` is not specified, then it will default to [DefaultNetworkServerConfig] instead.\\n\\n:::warning Network object will initially not be accessible to the client!\\nThe network object will initially not be accessible to the client. You need to call [NetworkServer:dispatch] \\nto render the network object accessible to the client!\\n:::","params":[{"name":"name","desc":"","lua_type":"string"},{"name":"middleware","desc":"","lua_type":"NetworkServerMiddleware?"},{"name":"config","desc":"","lua_type":"NetworkServerConfig?\\r\\n"}],"returns":[{"desc":"","lua_type":"NetworkServer\\r\\n"}],"function_type":"static","source":{"line":487,"path":"src/network/Server/init.luau"}},{"name":"fromName","desc":"Returns a network of the given name, if found.\\n\\n```lua\\n-- Script 1:\\nlocal network = NetworkServer.new(\\"Test\\")\\nnetwork:append(\\"key\\", \\"some value\\")\\nnetwork:dispatch(game:GetService(\\"ReplicatedStorage\\"))\\n\\n-- Script 2:\\nlocal testNetwork = NetworkServer.fromName(\\"Test\\")\\n```","params":[{"name":"name","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"NetworkServer?"}],"function_type":"static","source":{"line":533,"path":"src/network/Server/init.luau"}},{"name":"fromNamePromise","desc":"Promisified version of [NetworkServer.fromName].\\n\\n```lua\\n-- Script 1:\\nlocal network = NetworkServer.new(\\"Test\\")\\nnetwork:append(\\"key\\", \\"some value\\")\\nnetwork:dispatch(game:GetService(\\"ReplicatedStorage\\"))\\n\\n-- Script 2:\\nNetworkServer.fromNamePromise(\\"Test\\"):andThen(function(testNetwork)\\n\\tprint(testNetwork:dispatch()) \\nend)\\n```","params":[{"name":"name","desc":"","lua_type":"string"}],"returns":[{"desc":"","lua_type":"NetworkServer?"}],"function_type":"static","source":{"line":555,"path":"src/network/Server/init.luau"}},{"name":"is","desc":"Returns a boolean indicating if `self` is a network object or not.","params":[{"name":"self","desc":"","lua_type":"any"}],"returns":[{"desc":"","lua_type":"boolean\\r\\n"}],"function_type":"static","source":{"line":573,"path":"src/network/Server/init.luau"}},{"name":"dispatched","desc":"Returns a boolean indicating if the network object is dispatched to the \\nclient or not. ","params":[],"returns":[{"desc":"","lua_type":"boolean\\r\\n"}],"function_type":"method","source":{"line":582,"path":"src/network/Server/init.luau"}},{"name":"append","desc":"Appends a key-value pair, `key` and `value`, to the network object, so that\\nit is available to the client once the network object is dispatched. \\n\\nFor e.g:\\n\\n```lua\\n-- Server\\nlocal Workspace = game:GetService(\\"Workspace\\")\\n\\nlocal testNetwork = network.Server.new(\\"TestNetwork\\")\\ntestNetwork:append(\\"key\\", \\"the value!\\")\\ntestNetwork:dispatch(Workspace)\\n\\n-- Client\\nlocal testNetwork = Network.client.fromParent(\\"TestNetwork\\", Workspace):expect()\\nprint(testNetwork.key) --\x3e \\"the value!\\"\\n```\\n\\n:::tip More support\\nYou can also append a [RemoteSignal] and a [RemoteProperty] as well, they\'ll be represented as a [ClientRemoteSignal] and a [ClientRemoteProperty]\\nto the client respectively!\\n::: \\n\\n:::note Precaution!\\nIf the network object does not have a default middleware (`AutomaticArgumentSerializationAndDeserialization` specifically) set, \\nthen [argument limitations](https://create.roblox.com/docs/scripting/events/argument-limitations-for-bindables-and-remotes)\\nwill apply, as remote functions are internally used the key-value pairs accessible to the clients.\\n:::\\n\\n:::warning\\nThis method will error if the network object is dispatched to the client. \\nAlways make sure to append keys and values *before* you dispatch the \\nnetwork object. You can check if a network object is dispatched to the \\nclient or not through [NetworkServer:dispatched].\\n:::","params":[{"name":"key","desc":"","lua_type":"string"},{"name":"value","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","source":{"line":626,"path":"src/network/Server/init.luau"}},{"name":"dispatch","desc":"Dispatches the network folder of the network object to `parent`, rendering\\nthe network object accessible to the client now.\\n\\n:::warning\\nIf another network object of the same name as this network object is already\\ndispatched to `parent`, then this method will error - you can\'t have more than \\n1 network object of the same name dispatched to the same instance!\\n:::","params":[{"name":"parent","desc":"","lua_type":"Instance"}],"returns":[],"function_type":"method","source":{"line":646,"path":"src/network/Server/init.luau"}},{"name":"destroy","desc":"Destroys the network object and all appended remote properties &\\nremote signals within the network object, and renders the network \\nobject useless. ","params":[],"returns":[],"function_type":"method","source":{"line":656,"path":"src/network/Server/init.luau"}},{"name":"_setupRemoteObject","desc":"","params":[{"name":"key","desc":"","lua_type":"string"},{"name":"value","desc":"","lua_type":"RemoteProperty.RemoteProperty<any> | RemoteSignal.RemoteSignal\\r\\n"}],"returns":[],"function_type":"method","private":true,"source":{"line":664,"path":"src/network/Server/init.luau"}},{"name":"_setup","desc":"","params":[{"name":"key","desc":"","lua_type":"string"},{"name":"value","desc":"","lua_type":"any"}],"returns":[],"function_type":"method","private":true,"source":{"line":685,"path":"src/network/Server/init.luau"}},{"name":"_init","desc":"","params":[],"returns":[],"function_type":"method","private":true,"source":{"line":785,"path":"src/network/Server/init.luau"}},{"name":"_setupNetworkFolder","desc":"","params":[],"returns":[],"function_type":"method","private":true,"source":{"line":800,"path":"src/network/Server/init.luau"}}],"properties":[{"name":"RemoteProperty","desc":" ","lua_type":"RemoteProperty","tags":["Read only"],"source":{"line":13,"path":"src/network/Server/init.luau"}},{"name":"RemoteProperty","desc":" ","lua_type":"RemoteProperty","tags":["Read only"],"source":{"line":19,"path":"src/network/Server/init.luau"}}],"types":[{"name":"MethodCallInbound","desc":"","lua_type":"(methodName: string, client: Player, args: {any}) -> boolean","source":{"line":24,"path":"src/network/Server/init.luau"}},{"name":"MethodCallOutbound","desc":"","lua_type":"(methodName: string, client: Player, args: {any}, methodResponse: any) -> any","source":{"line":29,"path":"src/network/Server/init.luau"}},{"name":"ValueDispatch","desc":"","lua_type":"(client: Player, value: any) -> any","source":{"line":34,"path":"src/network/Server/init.luau"}},{"name":"DefaultNetworkServerConfig","desc":" ","fields":[{"name":"automaticArgumentSerializationAndDeserializationEnabled","lua_type":"true","desc":""},{"name":"promisifyCallbacks","lua_type":"true","desc":""}],"source":{"line":41,"path":"src/network/Server/init.luau"}},{"name":"DefaultNetworkServerMiddleware","desc":"","fields":[{"name":"methodCallInbound","lua_type":"{}","desc":""},{"name":"methodCallOutbound","lua_type":"{}","desc":""},{"name":"valueDispatch","lua_type":"{}","desc":""}],"source":{"line":49,"path":"src/network/Server/init.luau"}},{"name":"NetworkServerConfig","desc":" \\n\\n:::warning Remote Signal and Remote Property not subject to automatic serialization / deserialization!\\n[RemoteSignal] and [RemoteProperty] objects sent across the network by the network object will never be\\nserialized or deserialized, regardless of `automaticArgumentSerializationAndDeserializationEnabled`. They\'re\\nhandled internally to ensure they are properly replicated across the network.\\n:::\\n\\n- `automaticArgumentSerializationAndDeserializationEnabled` -> `true`\\n\\t- Arguments and values sent across the network by the network object\\n\\twill be automatically serialized and deserialized respectively, with the\\n\\thelp of an internal library, i.e [serializerUtil](https://bubshurb.github.io/libraries/api/serializerUtil/).\\n\\n\\t::note Serialization and deserialization limitations!\\n\\tWhile the serializer utility used to accomplish this supports a variety of data types, do keep in mind that not all data types\\n\\tcan be supported on the go for serialization and deserialization - check the above hyperlink to the serializer utility on how\\n\\tmany data types it supports.\\n\\t::::\\n\\n\\t**See the type of the value of `abc` being `TweenInfo` on the client**:\\n\\n\\t```lua\\n\\t-- Server\\n\\tlocal Workspace = game:GetService(\\"Workspace\\")\\n\\n\\tlocal testNetwork = network.Server.new(\\"TestNetwork\\", nil, {\\n\\t\\tautomaticArgumentSerializationAndDeserializationEnabled = true\\n\\t})\\n\\ttestNetwork:append(\\"abc\\", TweenInfo.new()) -- By default, TweenInfos\\n\\t-- are not replicated properlty across the  network, but watch the magic!\\n\\ttestNetwork:dispatch(Workspace)\\n\\n\\t-- Client\\n\\tlocal Workspace = game:GetService(\\"Workspace\\")\\n\\n\\tlocal testNetwork = network.client.fromParent(\\"TestNetwork\\", Workspace):expect()\\n\\tprint(typeof(testNetwork.abc)) --\x3e \\"TweenInfo\\"\\n\\t```\\n- `automaticArgumentSerializationAndDeserializationEnabled` -> `false`\\n\\t- Arguments and values sent across the network will not be internally serialized\\n\\tand deserialized. Using the same example as above:\\n\\n\\t**See the type of the value of `abc` being `table` on the client instead of `TweenInfo`**:\\n\\n\\t```lua\\n\\t-- Server\\n\\tlocal Workspace = game:GetService(\\"Workspace\\")\\n\\n\\tlocal testNetwork = network.Server.new(\\"TestNetwork\\", nil, {\\n\\t\\tautomaticArgumentSerializationAndDeserializationEnabled = false\\n\\t})\\n\\ttestNetwork:append(\\"abc\\", TweenInfo.new())\\n\\ttestNetwork:dispatch(Workspace)\\n\\n\\t-- Client\\n\\tlocal Workspace = game:GetService(\\"Workspace\\")\\n\\n\\tlocal testNetwork = network.client.fromParent(\\"abc\\", Workspace):expect()\\n\\tprint(typeof(testNetwork.abc)) --\x3e \\"table\\"\\n\\t```\\n\\n- `promisifyCallbacks` -> `true`:\\n\\n\\tServerside exposed callback called on the client will immediately return a promise which will be resolved\\n\\twith the return values of the callback.\\n\\n\\t```lua\\n\\t-- Server\\n\\tlocal Workspace = game:GetService(\\"Workspace\\")\\n\\n\\tlocal testNetwork = network.Server.new(\\"TestNetwork\\", nil, {\\n\\t\\tpromisifyCallbacks = true\\n\\t})\\n\\ttestNetwork:append(\\"method\\", function() return task.wait(5) end)\\n\\ttestNetwork:dispatch(Workspace)\\n\\n\\t-- Client\\n\\tlocal Workspace = game:GetService(\\"Workspace\\")\\n\\n\\tlocal testNetwork = network.client.fromParent(\\"abc\\", Workspace):expect()\\n\\ttestNetwork.method():andThen(function(deltaTime)\\n\\t\\tprint(typeof(deltaTime)) --\x3e \\"number\\"\\n\\tend)\\n\\t```\\n- `promisifyCallbacks` -> `false`:\\n\\n\\tServerside exposed callback called on the client will **not** return a promise and instead\\n\\twill yield the given thread until the callback has returned back to the caller.\\n\\n\\t```lua\\n\\t-- Server\\n\\tlocal Workspace = game:GetService(\\"Workspace\\")\\n\\n\\tlocal testNetwork = network.Server.new(\\"TestNetwork\\", nil, {\\n\\t\\tpromisifyCallbacks = false\\n\\t})\\n\\ttestNetwork:append(\\"method\\", function() return task.wait(5) end)\\n\\ttestNetwork:dispatch(Workspace)\\n\\n\\t-- Client\\n\\tlocal Workspace = game:GetService(\\"Workspace\\")\\n\\n\\tlocal testNetwork = network.client.fromParent(\\"abc\\", Workspace):expect()\\n\\tprint(typeof(testNetwork.method())) --\x3e \\"number\\" (Thread is yielded for approx 5 seconds)\\n\\t```","fields":[{"name":"automaticArgumentSerializationAndDeserializationEnabled","lua_type":"boolean","desc":"determines whether or not values sent to clients by the remote signal be internally serialized/deserialized or not."},{"name":"promisifyCallbacks","lua_type":"boolean","desc":"determines whether or not a promise is returned to the client (resolved with the return values of the callback) whenever they call a serverside exposed callback"}],"source":{"line":160,"path":"src/network/Server/init.luau"}},{"name":"NetworkServer","desc":" ","lua_type":"NetworkServer","source":{"line":165,"path":"src/network/Server/init.luau"}},{"name":"NetworkServerMiddleware","desc":"`methodCallInbound`, `methodCallOutbound` and `valueDispatch` must be an array of callbacks, if specified. \\n\\n:::warning Yielding in middleware callbacks is not allowed\\nMiddleware callbacks aren\'t allowed to yield. If they do so, their thread will be closed via\\n[coroutine.close](https://create.roblox.com/docs/reference/engine/libraries/coroutine#close) and an\\nerror will be outputted in the console.\\n\\nYielding, (especially in network-related code) results in weird bugs and behavior which can be hard to track down!\\n:::\\n\\n### `methodCallInbound` \\n\\nCallbacks in `methodCallInbound` are called whenever a client tries to call any of the appended methods of the network. \\n\\nThe first argument passed to each callback is the name of the method (the client called), and the second argument, i.e \\nthe arguments sent by the client, which are packed into an array. \\n\\n```lua\\nlocal methodCallInboundCallbacks = {\\n\\tfunction (methodName, client: Player, arguments)\\n\\t\\tprint(client:IsA(\\"Player\\")) --\x3e true \\n\\t\\tprint(typeof(arguments)) --\x3e \\"table\\"\\n\\tend\\n}\\n---\\n```\\n\\n:::tip More control\\n- If any of the callbacks return an **explicit** false value, then the method which the client tried to call, will *not* be\\ncalled. This is useful as you can implement for e.g, implementing rate limits!\\n\\n- Additionally, you can modify the `arguments` table which will be reflected in the method, for e.g:\\n\\n```lua\\n-- Server\\nlocal Workspace = game:GetService(\\"Workspace\\")\\n\\nlocal testNetwork = network.Server.new(\\"TestNetwork\\", {methodCallInbound = {\\n\\tfunction(_, _, arguments) \\n\\t\\targuments[2] = \\"test\\"\\n\\tend\\n}})\\ntestNetwork:append(\\"method\\", function(player, a)\\n\\tprint(a) --\x3e \\"test\\" (a ought to be 1, but the middleware modified it!)\\nend)\\ntestNetwork:dispatch(Workspace)\\n\\n-- Client\\nlocal Workspace = game:GetService(\\"Workspace\\")\\n\\nlocal testNetwork = network.client.fromParent(\\"TestNetwork\\", Workspace):expect()\\ntestNetwork.method(1) \\n```\\n:::\\n\\n### `methodCallOutbound` \\n\\nCallbacks in `methodCallOutbound` are called whenever a method (appended to the network) is called by the client, and \\nhas **finished** running.  \\n\\nThe first argument passed to each callback is the name of the method (client called), and the second argument, i.e \\nthe arguments sent by the client, which are packed into an array. \\n\\nA third argument i.e `methodResponse` is passed to each callback as well, which is just the response of the method called. \\n\\n```lua\\nlocal methodCallOutboundCallbacks = {\\n\\tfunction (methodName, client: Player, arguments, methodResponse)\\n\\t\\tprint(client:IsA(\\"Player\\")) --\x3e true \\n\\t\\tprint(typeof(arguments)) --\x3e \\"table\\"\\n\\tend\\n}\\n---\\n```\\n\\nAdditionally, these callbacks can return a value that overrides the actual result of the method (which will be sent\\nback to the client). For e.g:\\n\\n```lua\\n-- Server:\\nlocal Workspace = game:GetService(\\"Workspace\\")\\n\\nlocal middleware = {\\n\\t{\\n\\t\\tfunction (methodName, arguments, methodResponse)\\n\\t\\t\\tprint(methodResponse) --\x3e \\"this\\"\\n\\t\\t\\treturn 50\\n\\t\\tend\\n\\t}\\n}\\n\\nlocal testNetwork = network.Server.new(\\"TestNetwork\\", middleware)\\ntestNetwork:append(\\"someMethod\\", function()\\n\\treturn \\"this\\"\\nend)\\ntestNetwork:dispatch(Workspace)\\n\\n-- Client:\\nlocal Workspace = game:GetService(\\"Workspace\\")\\n\\nlocal testNetwork = network.fromParent(\\"TestNetwork\\", Workspace):expect()\\nprint(testNetwork.someMethod()) --\x3e 50 \\n```\\n\\nAdditionally, if more than 1 callback returns a value, then all those returned values will be packed into an array and *then* sent\\nback to the client. This is by design, as it isn\'t ideal to disregard all returned values for just 1.\\n\\nFor e.g: \\n\\n```lua\\n-- Server:\\nlocal Workspace = game:GetService(\\"Workspace\\")\\n\\nlocal middleware = {\\n\\t{\\n\\t\\tfunction (methodName, arguments, response)\\n\\t\\t\\treturn 1\\n\\t\\tend,\\n\\n\\t\\tfunction (methodName, arguments, response)\\n\\t\\t\\treturn 2\\n\\t\\tend,\\n\\n\\t\\tfunction (methodName, arguments, response)\\n\\t\\t\\treturn 3\\n\\t\\tend\\n\\t}\\n}\\n\\nlocal testNetwork = network.server.new(\\"TestNetwork\\", middleware)\\ntestNetwork:append(\\"someMethod\\", function()\\n\\treturn \\"this\\"\\nend)\\ntestNetwork:dispatch(Workspace)\\n\\n-- Client:\\nlocal Workspace = game:GetService(\\"Workspace\\")\\n\\nlocal testNetwork = network.client.fromParent(\\"TestNetwork\\", Workspace):expect()\\nprint(testNetwork.someMethod()) --\x3e {1, 2, 3} \\n```\\n\\n### `valueDispatch` \\n\\nCallbacks in `valueDispatch` are called whenever the network object replicates a value (**specifically a non function and not a remote signal\\nand not a remote property**), e.g a table, number, string, etc.\\n\\nThe first argument passed to each callback is the client itself whom the value is going to replicate to, and the value.\\n\\n```lua\\nlocal valueDispatchCallbacks = {\\n\\tfunction (client, value)\\n\\t\\t---\\n\\tend,\\n   \\n}\\n---\\n```\\n\\nThe return value of the callback will be used in favour of the original value. If more than 1 callback returns\\na value, all of them will be packed into an array and *then* sent.\\n\\n```lua\\nlocal Workspace = game:GetService(\\"Workspace\\")\\n\\n-- Server\\nlocal valueDispatchCallbacks = {\\n\\tfunction (client, value)\\n\\t\\treturn {\\n\\t\\t\\ttest = 1\\n\\t\\t}\\n\\tend,\\n   \\n}\\n\\nlocal testNetwork = network.Server.new(\\"TestNetwork\\", {valueDispatch = valueDispatchCallbacks})\\ntestNetwork:append(\\"someValue\\", 5)\\ntestNetwork:dispatch(Workspace)\\n\\n-- Client\\nlocal Workspace = game:GetService(\\"Workspace\\")\\n\\nlocal testNetwork = network.client.fromParent(\\"TestNetwork\\", Workspace):expect()\\nprint(testNetwork.someValue) --\x3e {test = 1} (this thought to be 5, but the middleware returned a table instead)\\n```\\n\\n```lua\\n-- Server\\nlocal Workspace = game:GetService(\\"Workspace\\")\\n\\nlocal valueDispatchCallbacks = {\\n\\tfunction (client, value)\\n\\t\\tprint(value) --\x3e 5\\n\\t\\treturn 1\\n\\tend,\\n\\t\\n\\tfunction (client, value)\\n\\t\\tprint(value) --\x3e 5\\n\\t \\treturn 2\\n\\tend\\n}\\n\\nlocal testNetwork = network.Server.new(\\"TestNetwork\\", {valueDispatch = valueDispatchCallbacks})\\ntestNetwork:append(\\"someValue\\", 5)\\ntestNetwork:dispatch(Workspace)\\n\\n-- Client\\nlocal Workspace = game:GetService(\\"Workspace\\")\\n\\nlocal testNetwork = network.client.fromParent(\\"TestNetwork\\", Workspace):expect()\\nprint(testNetwork.someValue) --\x3e {1, 2}\\n---\\n```\\n\\n:::tip More control\\n- If any of the callbacks return a `nil` value, then the value will not be replicated to the client. For e.g:\\n\\n```lua\\nlocal Workspace = game:GetService(\\"Workspace\\")\\n\\n-- Server\\nlocal valueDispatchCallbacks = {\\n\\tfunction (client, value)\\n\\t\\treturn nil\\n\\tend,\\n   \\n}\\n\\nlocal testNetwork = network.Server.new(\\"TestNetwork\\", {valueDispatch = valueDispatchCallbacks})\\ntestNetwork:append(\\"someValue\\", 5)\\ntestNetwork:dispatch(Workspace)\\n\\n-- Client\\nlocal Workspace = game:GetService(\\"Workspace\\")\\n\\nlocal testNetwork = network.client.fromParent(\\"TestNetwork\\", Workspace):expect()\\nprint(testNetwork.someValue) --\x3e nil (this thought to be 5, but the middleware returned a nil value instead)\\n```\\n:::","fields":[{"name":"methodCallInbound","lua_type":"MethodCallInbound?","desc":"Before a callback runs."},{"name":"methodCallOutbound","lua_type":"MethodCallOutbound?","desc":"After a callback has finished running."},{"name":"valueDispatch","lua_type":"ValueDispatch?","desc":"Affects the return value of the callbacks (to the clients) after they\'ve run."}],"source":{"line":413,"path":"src/network/Server/init.luau"}}],"name":"NetworkServer","desc":"The server counterpart of [network].","realm":["Server"],"source":{"line":7,"path":"src/network/Server/init.luau"}}')}}]);