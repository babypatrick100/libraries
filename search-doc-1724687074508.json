[{"title":"beamUtil","type":0,"sectionRef":"#","url":"/libraries/api/beamUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"beamUtil","url":"/libraries/api/beamUtil#functions","content":" "},{"title":"attachBeam​","type":1,"pageTitle":"beamUtil","url":"/libraries/api/beamUtil#attachBeam","content":"&lt;/&gt; beamUtil.attachBeam( beam: Beam , a0: Attachment , part: BasePart , beamParent: Instance ) → () Attaches the given beam. "},{"title":"colorUtil","type":0,"sectionRef":"#","url":"/libraries/api/colorUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"colorUtil","url":"/libraries/api/colorUtil#functions","content":" "},{"title":"darkenColor​","type":1,"pageTitle":"colorUtil","url":"/libraries/api/colorUtil#darkenColor","content":"&lt;/&gt; colorUtil.darkenColor( color: Color3 , delta: number ) → Color3  Returns a darker version of the given color. delta is the amount by which the given color should be darkened.  "},{"title":"clampColor​","type":1,"pageTitle":"colorUtil","url":"/libraries/api/colorUtil#clampColor","content":"&lt;/&gt; colorUtil.clampColor( colorOrColorSequence: Color3 | ColorSequence , clampComponents: { minH: number, maxH: number, minS: number, maxS: number, minV: number, maxV: number, } ) → Color3 | ColorSequence  Returns a clamped version of the given colorOrColorSequence. "},{"title":"basePartSizeUtil","type":0,"sectionRef":"#","url":"/libraries/api/basePartSizeUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"basePartSizeUtil","url":"/libraries/api/basePartSizeUtil#functions","content":" "},{"title":"resizeOnXAxis​","type":1,"pageTitle":"basePartSizeUtil","url":"/libraries/api/basePartSizeUtil#resizeOnXAxis","content":"&lt;/&gt; basePartSizeUtil.resizeOnXAxis( basePart: BasePart , newX: number, tweenInfo: TweenInfo? ) → () Resizes the given basePart's Size's X to newX. Returns a promise once the operation is successful.  "},{"title":"resizeOnYAxis​","type":1,"pageTitle":"basePartSizeUtil","url":"/libraries/api/basePartSizeUtil#resizeOnYAxis","content":"&lt;/&gt; basePartSizeUtil.resizeOnYAxis( basePart: BasePart , newY: number, tweenInfo: TweenInfo? ) → () Resizes the given basePart's Size's Y to newY. Returns a promise once the operation is successful.  "},{"title":"resizeOnZAxis​","type":1,"pageTitle":"basePartSizeUtil","url":"/libraries/api/basePartSizeUtil#resizeOnZAxis","content":"&lt;/&gt; basePartSizeUtil.resizeOnZAxis( basePart: BasePart , newZ: number, tweenInfo: TweenInfo? ) → () Resizes the given basePart's Size's Z to newZ. Returns a promise once the operation is successful. "},{"title":"clientIdleStatusUtil","type":0,"sectionRef":"#","url":"/libraries/api/clientIdleStatusUtil","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"clientIdleStatusUtil","url":"/libraries/api/clientIdleStatusUtil#types","content":" "},{"title":"IdleStatus​","type":1,"pageTitle":"clientIdleStatusUtil","url":"/libraries/api/clientIdleStatusUtil#IdleStatus","content":"&lt;/&gt; interface IdleStatus { Idle: &quot;Idle&quot; UnIdle: &quot;UnIdle&quot; }  "},{"title":"Properties​","type":1,"pageTitle":"clientIdleStatusUtil","url":"/libraries/api/clientIdleStatusUtil#properties","content":" "},{"title":"idleStatusProperty​","type":1,"pageTitle":"clientIdleStatusUtil","url":"/libraries/api/clientIdleStatusUtil#idleStatusProperty","content":"This item is read only and cannot be modified. Read Only &lt;/&gt; clientIdleStatusUtil.idleStatusProperty: Property&lt;newIdleStatus: string,oldIdleStatus: string?&gt; A property which is fired whenever the value of the property is set to a new one. The signal is only passed the new value as the only argument. "},{"title":"clientMouseUtil","type":0,"sectionRef":"#","url":"/libraries/api/clientMouseUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"clientMouseUtil","url":"/libraries/api/clientMouseUtil#functions","content":" "},{"title":"registerMouseHoverStart​","type":1,"pageTitle":"clientMouseUtil","url":"/libraries/api/clientMouseUtil#registerMouseHoverStart","content":"&lt;/&gt; clientMouseUtil.registerMouseHoverStart( callback: ( instance: Instance , mousePosition: Vector2 ) → (), minActivationDistance: number?, maxActivationDistance: number? ) → Connection Registers the given callback which is called whenever the player hovers over a 3D instance.  "},{"title":"registerMouseHoverEnd​","type":1,"pageTitle":"clientMouseUtil","url":"/libraries/api/clientMouseUtil#registerMouseHoverEnd","content":"&lt;/&gt; clientMouseUtil.registerMouseHoverEnd(callback: ( instance: Instance , mousePosition: Vector2 ) → ()) → Connection Registers the given callback which is called whenever the player no longer over a 3D instance. "},{"title":"colorSequenceUtil","type":0,"sectionRef":"#","url":"/libraries/api/colorSequenceUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"colorSequenceUtil","url":"/libraries/api/colorSequenceUtil#functions","content":" "},{"title":"colorFromKeyPointsPercentage​","type":1,"pageTitle":"colorSequenceUtil","url":"/libraries/api/colorSequenceUtil#colorFromKeyPointsPercentage","content":"&lt;/&gt; colorSequenceUtil.colorFromKeyPointsPercentage( percentage: number, colorSequenceKeyPoints: {ColorSequenceKeypoint } ) → () Returns a color based on where the percentage lies in the specified color sequence key points. (Credits; ToldFable) "},{"title":"contextActionServiceUtil","type":0,"sectionRef":"#","url":"/libraries/api/contextActionServiceUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"contextActionServiceUtil","url":"/libraries/api/contextActionServiceUtil#functions","content":" "},{"title":"bindActionNoInputSink​","type":1,"pageTitle":"contextActionServiceUtil","url":"/libraries/api/contextActionServiceUtil#bindActionNoInputSink","content":"&lt;/&gt; contextActionServiceUtil.bindActionNoInputSink( actionName: string, actionCallback: ( actionName: string, inputState: Enum.UserInputState, inputObject: InputObject ) → (), createTouchButton: boolean, ...: Enum.UserInputType | Enum.KeyCode ) → () Works almost exactly the same as ContextActionService:BindAction, except that a custom handler is passed as the 2nd argument, which then calls actionCallbackbut returns Enum.ContextActionResult.Pass so the handler never sinks any inputs. You can think of the custom handler like this: function(...) actionCallback(...) return Enum.ContextActionResult.Pass end contextActionServiceUtil.bindActionNoInputSink( &quot;Input&quot;, function(_, inputState: Enum.UserInputState, inputObject: InputObject) print(&quot;User pressed Enum.Keycode.A&quot;) end, false, Enum.Keycode.A )  "},{"title":"custom","type":0,"sectionRef":"#","url":"/libraries/api/custom","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"custom","url":"/libraries/api/custom#functions","content":" "},{"title":"class​","type":1,"pageTitle":"custom","url":"/libraries/api/custom#class","content":"&lt;/&gt; custom.class( instance: Instance , className: string ) → () A custom callback for FindFirstChildOfClass. waitForUtil.custom.class(Workspace, &quot;TextLabel&quot;):andThen(function(textLabel: TextLabel) print(basePart.ClassName == &quot;TextLabel&quot;) --&gt; true end)   "},{"title":"isA​","type":1,"pageTitle":"custom","url":"/libraries/api/custom#isA","content":"&lt;/&gt; custom.isA( instance: Instance , isA: string ) → () A custom callback for FindFirstChildWhichIsA. waitForUtil.custom.class(Workspace, &quot;BasePart&quot;):andThen(function(basePart: BasePart) print(basePart:IsA(&quot;BasePart&quot;)) --&gt; true end)  "},{"title":"badgeServiceUtil","type":0,"sectionRef":"#","url":"/libraries/api/badgeServiceUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"badgeServiceUtil","url":"/libraries/api/badgeServiceUtil#functions","content":" "},{"title":"badgeInfo​","type":1,"pageTitle":"badgeServiceUtil","url":"/libraries/api/badgeServiceUtil#badgeInfo","content":"&lt;/&gt; badgeServiceUtil.badgeInfo(badgeId: number) → Promise&lt;BadgeInfo&gt; "},{"title":"Types","type":1,"pageTitle":"badgeServiceUtil","url":"/libraries/api/badgeServiceUtil##","content":""},{"title":"​","type":1,"pageTitle":"badgeServiceUtil","url":"/libraries/api/badgeServiceUtil#BadgeInfo","content":"interface BadgeInfo { Name: string Description: boolean IconImageId: number IsEnabled: boolean }  Returns a promise which is resolved wih the badge info of the given badge id. This is just a wrapper over BadgeService:GetBadgeInfoAsync.  "},{"title":"playerHasBadge​","type":1,"pageTitle":"badgeServiceUtil","url":"/libraries/api/badgeServiceUtil#playerHasBadge","content":"&lt;/&gt; badgeServiceUtil.playerHasBadge( playerUserId: number, badgeId: number ) → Promise&lt;boolean&gt; Returns a promise which is resolved wih a boolean indicating whether or not the given player has the specified badge or not. This is just a wrapper over BadgeService:UserHasBadgeAsync. local wasSuccessful, playerHasBadge, errorMessage = badgeServiceUtil.playerHasBadge( 123, 123 ):await() note Incase the promise is rejected, playerHasBadge will always be false.  "},{"title":"awardBadgeToPlayer​","type":1,"pageTitle":"badgeServiceUtil","url":"/libraries/api/badgeServiceUtil#awardBadgeToPlayer","content":"&lt;/&gt; badgeServiceUtil.awardBadgeToPlayer( playerUserId: number, badgeId: number ) → Promise&lt;boolean&gt; Returns a promise which is resolved once the given player has being successfully awarded with the given badge. This is just a wrapper over BadgeService:AwardBadge. local wasSuccessful, errorMessage = badgeServiceUtil.awardBadgeToPlayer(123, 123):await()  "},{"title":"coreGuiUtil","type":0,"sectionRef":"#","url":"/libraries/api/coreGuiUtil","content":"","keywords":""},{"title":"evLightning","type":0,"sectionRef":"#","url":"/libraries/api/evLightning","content":"On this page evLightning Evaera's evLighning module ported to wally.","keywords":""},{"title":"Functions​","type":1,"pageTitle":"coreGuiUtil","url":"/libraries/api/coreGuiUtil#functions","content":" "},{"title":"setCore​","type":1,"pageTitle":"coreGuiUtil","url":"/libraries/api/coreGuiUtil#setCore","content":"&lt;/&gt; coreGuiUtil.setCore( coreGuiName: string, ...: any ) → Promise&lt;&gt; Returns a promise which is resolved once StarterGui:SetCore has successfully executed. coreGuiUtil.setCore(&quot;AvatarContextMenuTheme&quot;, { BackgroundImage = &quot;&quot;, BackgroundTransparency = 0.5, BackgroundColor = Color3.fromRGB(111, 145, 242), NameTagColor = Color3.fromRGB(0, 0, 200), NameUnderlineColor = Color3.fromRGB(213, 233, 255), ButtonFrameColor = Color3.fromRGB(15, 24, 65), ButtonFrameTransparency = 0.2, ButtonUnderlineColor = Color3.fromRGB(213, 233, 255), Font = Enum.Font.SciFi }):andThen(function() print(&quot;Successfully set core AvatarContextMenuTheme&quot;) end)  "},{"title":"dateUtil","type":0,"sectionRef":"#","url":"/libraries/api/dateUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"dateUtil","url":"/libraries/api/dateUtil#functions","content":" "},{"title":"daysInMonth​","type":1,"pageTitle":"dateUtil","url":"/libraries/api/dateUtil#daysInMonth","content":"&lt;/&gt; dateUtil.daysInMonth( year: number, month: number ) → number Returns the number of days in the given month. print(dateUtil.daysInMonth(2023, 6)) --&gt; 30   "},{"title":"ordinal​","type":1,"pageTitle":"dateUtil","url":"/libraries/api/dateUtil#ordinal","content":"&lt;/&gt; dateUtil.ordinal(number: number) → string Returns the given number in ordinal format. print(dateUtil.ordinal(24)) --&gt; 24th   "},{"title":"stringifiedMonth​","type":1,"pageTitle":"dateUtil","url":"/libraries/api/dateUtil#stringifiedMonth","content":"&lt;/&gt; dateUtil.stringifiedMonth(month: number) → string Returns a stringified month. print(dateUtil.stringifiedMonth(3)) --&gt; &quot;March&quot;   "},{"title":"yearIsLeapYear​","type":1,"pageTitle":"dateUtil","url":"/libraries/api/dateUtil#yearIsLeapYear","content":"&lt;/&gt; dateUtil.yearIsLeapYear(year: number) → boolean Returns a boolean indicating whether or not the given year is a leap year. print(dateUtil.yearIsLeapYear(2024)) --&gt; true  "},{"title":"debugLoggerUtil","type":0,"sectionRef":"#","url":"/libraries/api/debugLoggerUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"debugLoggerUtil","url":"/libraries/api/debugLoggerUtil#functions","content":" "},{"title":"toggleLoggingEnabledGlobal​","type":1,"pageTitle":"debugLoggerUtil","url":"/libraries/api/debugLoggerUtil#toggleLoggingEnabledGlobal","content":"&lt;/&gt; debugLoggerUtil.toggleLoggingEnabledGlobal(toggle: boolean) → () Toggles if logging is enabled or not globally. debugLoggerUtil.toggleLoggingEnabledGlobal(false) debugLoggerUtil.log(warn, &quot;test&quot;) -- Doesn't do anything   "},{"title":"toggleLoggingEnabled​","type":1,"pageTitle":"debugLoggerUtil","url":"/libraries/api/debugLoggerUtil#toggleLoggingEnabled","content":"&lt;/&gt; debugLoggerUtil.toggleLoggingEnabled(toggle: boolean) → () Toggles if logging is enabled or not for the script. debugLoggerUtil.toggleLoggingEnabled(false) debugLoggerUtil.log(warn, &quot;test&quot;) -- Doesn't do anything -- In another script.. debugLoggerUtil.log(warn, &quot;123&quot;) -- Works   "},{"title":"log​","type":1,"pageTitle":"debugLoggerUtil","url":"/libraries/api/debugLoggerUtil#log","content":"&lt;/&gt; debugLoggerUtil.log( logFunction: (...any) → (), ...: any ) → () Calls logFunction passing in ... to it -- if logging is not enabled, nothing happens. note If logging is toggled off for the script (in which this method is called in) or logging is toggled off globally, then this method will not anything. "},{"title":"guiObjectFadeUtil","type":0,"sectionRef":"#","url":"/libraries/api/guiObjectFadeUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"guiObjectFadeUtil","url":"/libraries/api/guiObjectFadeUtil#functions","content":" "},{"title":"fadeIn​","type":1,"pageTitle":"guiObjectFadeUtil","url":"/libraries/api/guiObjectFadeUtil#fadeIn","content":"&lt;/&gt; guiObjectFadeUtil.fadeIn( guiObject: GuiObject , fadeTime: number ) → () Fades in the given guiObject.  "},{"title":"fadeOut​","type":1,"pageTitle":"guiObjectFadeUtil","url":"/libraries/api/guiObjectFadeUtil#fadeOut","content":"&lt;/&gt; guiObjectFadeUtil.fadeOut( guiObject: GuiObject , fadeTime: number, override: number? ) → () Fades out the given guiObject. "},{"title":"ClientRemoteProperty","type":0,"sectionRef":"#","url":"/libraries/api/ClientRemoteProperty","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ClientRemoteProperty","url":"/libraries/api/ClientRemoteProperty#types","content":" "},{"title":"ClientRemoteProperty​","type":1,"pageTitle":"ClientRemoteProperty","url":"/libraries/api/ClientRemoteProperty#ClientRemoteProperty","content":"&lt;/&gt; type ClientRemoteProperty = ClientRemoteProperty  "},{"title":"Properties​","type":1,"pageTitle":"ClientRemoteProperty","url":"/libraries/api/ClientRemoteProperty#properties","content":" "},{"title":"onUpdate​","type":1,"pageTitle":"ClientRemoteProperty","url":"/libraries/api/ClientRemoteProperty#onUpdate","content":"Read only Signal ClientRemoteProperty instance &lt;/&gt; ClientRemoteProperty.onUpdate: Signal&lt;newValue: any,oldValue: any&gt; A signal which is fired, whenever the value of the remote property (or the value of the client stored in the remote property) is updated. Incase the client has a specific value set for them in the remote property, then this signal will only fire if that value has been updated. "},{"title":"Functions​","type":1,"pageTitle":"ClientRemoteProperty","url":"/libraries/api/ClientRemoteProperty#functions","content":" "},{"title":"is​","type":1,"pageTitle":"ClientRemoteProperty","url":"/libraries/api/ClientRemoteProperty#is","content":"&lt;/&gt; ClientRemoteProperty.is(self: any) → boolean Returns a boolean indicating if self is a client remote property or not.  "},{"title":"get​","type":1,"pageTitle":"ClientRemoteProperty","url":"/libraries/api/ClientRemoteProperty#get","content":"ClientRemoteProperty instance &lt;/&gt; ClientRemoteProperty:get() → any Returns the value of the client stored in the remote property. If there is no value stored specifically for the client, then the remote property's current value will be returned instead.  "},{"title":"observe​","type":1,"pageTitle":"ClientRemoteProperty","url":"/libraries/api/ClientRemoteProperty#observe","content":"ClientRemoteProperty instance &lt;/&gt; ClientRemoteProperty:observe(callback: ( newValue: any, oldValue: any ) → ()) → () Observes the value of the client remote property. clientRemoteProperty:observe(function(newValue, oldValue) end)   "},{"title":"valuePromise​","type":1,"pageTitle":"ClientRemoteProperty","url":"/libraries/api/ClientRemoteProperty#valuePromise","content":"ClientRemoteProperty instance &lt;/&gt; ClientRemoteProperty:valuePromise(valuePredicate: (( newValue: any, oldValue: any ) → boolean)?) → () Returns a promise which is resolved with a non-nil value of the client remote property, given that valuePredicate is not passed as an argument. clientRemoteProperty:valuePromise():andThen(function(value) print(value) end) valuePredicate can ALSO be passed, which allows you to filter out values. If it returns exactly true, only then will the promise resolve with the new value. clientRemoteProperty:valuePromise(function(newValue, oldValue) print(newValue, oldValue) return oldValue == 1 end):andThen(function(value) print(value) end) clientRemoteProperty:set(1) clientRemoteProperty:set(2) -- Output: -- 1, nil -- 2, 1 -- 2   "},{"title":"set​","type":1,"pageTitle":"ClientRemoteProperty","url":"/libraries/api/ClientRemoteProperty#set","content":"ClientRemoteProperty instance &lt;/&gt; ClientRemoteProperty:set(value: any) → () Invokes the remote property, to set the value for the client to value. Possible rate limit It is possible that the client may be rate limited by the server (see RemoteProperty:setRateLimitForClientSettingValue), and thus requests to the server to set the value for the client can possibly be ignored by the server. -- Server remoteProperty:setRateLimitForClientSettingValue(client, 30) -- 30 seconds -- Client clientRemoteProperty.onUpdate:Connect(function(newValue) print(newValue) end) -- Spam the setting of value for the client, so we ought for the value of the -- client stored in the remote property (finally) to be `100`, but instead -- it will be `1`, as subsequent calls after the first one will be ignored -- due to the rate limit imposed. for index = 1, 100 do clientRemoteProperty:set(index) end --&gt; 1 Possible Value Set Request Rejection From Server The server can decline the client's request of setting the value for the client in the remote property. This behavior will be seen by default, if the remote property has no clientSet middleware - see DefaultRemotePropertyMiddleware and RemotePropertyMiddleware for more info.  "},{"title":"setPromise​","type":1,"pageTitle":"ClientRemoteProperty","url":"/libraries/api/ClientRemoteProperty#setPromise","content":"ClientRemoteProperty instance Advanced &lt;/&gt; ClientRemoteProperty:setPromise(value: any) → Promise Works the same as ClientRemoteProperty:set, but returns a promise which is resolved when the server has set the value for the client to value, or else rejects with a nil value. Additionally, the returned promise resolves with the value (that was set). Precaution This method performs a shallow check (self:get() == value) before informing the server to actually set the value. This is an attempt to avoid sending unnecessary requests to the server. -- Example 1: local thisValue = {1,2,3} clientRemoteProperty:setPromise(thisValue):expect() -- Assuming this is successful.... warn(clientRemoteProperty:setPromise(thisValue):expect()) -- Does not inform the server, immediately returns a resolved promise -- Example 2: local thisValue = &quot;123&quot; clientRemoteProperty:setPromise(thisValue):expect() -- Assuming this is successful.... warn(clientRemoteProperty:setPromise(thisValue):expect()) -- Does not inform the server to set the value to 'thisValue' (redundant!) Possible Promise rejection This promise can also be rejected with a nil value if the server declines the client's request of setting the value for the client in the remote property. This behavior will be seen by default, if the remote property has no clientSet middleware - see DefaultRemotePropertyMiddleware and RemotePropertyMiddleware for more info. -- Client clientRemoteProperty:setPromise(10):andThen(function(newValue) -- Success! print(newValue) --&gt; 10 end):catch(function() -- Server rejected the request end)   "},{"title":"destroy​","type":1,"pageTitle":"ClientRemoteProperty","url":"/libraries/api/ClientRemoteProperty#destroy","content":"ClientRemoteProperty instance &lt;/&gt; ClientRemoteProperty:destroy() → () Destroys the client remote property and renders it unusable. "},{"title":"ClientRemoteSignal","type":0,"sectionRef":"#","url":"/libraries/api/ClientRemoteSignal","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ClientRemoteSignal","url":"/libraries/api/ClientRemoteSignal#types","content":" "},{"title":"ClientRemoteSignal​","type":1,"pageTitle":"ClientRemoteSignal","url":"/libraries/api/ClientRemoteSignal#ClientRemoteSignal","content":"&lt;/&gt; type ClientRemoteSignal = ClientRemoteSignal  "},{"title":"Functions​","type":1,"pageTitle":"ClientRemoteSignal","url":"/libraries/api/ClientRemoteSignal#functions","content":" "},{"title":"is​","type":1,"pageTitle":"ClientRemoteSignal","url":"/libraries/api/ClientRemoteSignal#is","content":"&lt;/&gt; ClientRemoteSignal.is(self: any) → boolean Returns a boolean indicating if self is a client remote signal or not.  "},{"title":"connect​","type":1,"pageTitle":"ClientRemoteSignal","url":"/libraries/api/ClientRemoteSignal#connect","content":"ClientRemoteSignal instance &lt;/&gt; ClientRemoteSignal:connect(callback: (...any) → ()) → RBXScriptConnection  Connects callback to the client remote signal so that it is called whenever the remote signal dispatches some data to the client. Additionally, callback will be passed all the arguments sent by the server.  "},{"title":"once​","type":1,"pageTitle":"ClientRemoteSignal","url":"/libraries/api/ClientRemoteSignal#once","content":"ClientRemoteSignal instance &lt;/&gt; ClientRemoteSignal:once(callback: (...any) → ()) → RBXScriptConnection  Works almost exactly the same as ClientRemoteSignal:connect, except the connection returned is disconnected immediately upon callback being called.  "},{"title":"fireServer​","type":1,"pageTitle":"ClientRemoteSignal","url":"/libraries/api/ClientRemoteSignal#fireServer","content":"ClientRemoteSignal instance &lt;/&gt; ClientRemoteSignal:fireServer(...: any) → () Fires ... arguments to the remote signal.  "},{"title":"wait​","type":1,"pageTitle":"ClientRemoteSignal","url":"/libraries/api/ClientRemoteSignal#wait","content":"ClientRemoteSignal instance yields &lt;/&gt; ClientRemoteSignal:wait() → ...any Yields the current thread until the remote signal dispatches some data to the client. The yielded thread is resumed once the server fires some data to the client, with the arguments sent by the server. -- Server remoteSignal:fireAllClients(&quot;Hi&quot;) -- Client print(clientRemoteSignal:wait()) --&gt; &quot;Hi&quot;   "},{"title":"destroy​","type":1,"pageTitle":"ClientRemoteSignal","url":"/libraries/api/ClientRemoteSignal#destroy","content":"ClientRemoteSignal instance &lt;/&gt; ClientRemoteSignal:destroy() → () Destroys the client remote signal and renders it unusable. "},{"title":"Hover","type":0,"sectionRef":"#","url":"/libraries/api/Hover","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Hover","url":"/libraries/api/Hover#types","content":" "},{"title":"Hover​","type":1,"pageTitle":"Hover","url":"/libraries/api/Hover#Hover","content":"&lt;/&gt; type Hover = Hover  "},{"title":"Functions​","type":1,"pageTitle":"Hover","url":"/libraries/api/Hover#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Hover","url":"/libraries/api/Hover#new","content":"&lt;/&gt; Hover.new( x: number?, y: number?, z: number? ) → Hover Constructs a new hover object, with forces x, y and z which can only be 0 and 1. These forces determine on which axis the hover effect is applied to - e.g if x is 1, then the hover effect will be applied on the X axis and if y is 1, then the hover effect will be applied on the Y axis. note x and z will both default to 0 if not specified but y will default to 1 if not specified - which means by default, the hover effect will always be applied on the Y axis.  "},{"title":"pause​","type":1,"pageTitle":"Hover","url":"/libraries/api/Hover#pause","content":"&lt;/&gt; Hover:pause() → () Pauses the hover effect.  "},{"title":"resume​","type":1,"pageTitle":"Hover","url":"/libraries/api/Hover#resume","content":"&lt;/&gt; Hover:resume() → () Resumes the hover effect.  "},{"title":"update​","type":1,"pageTitle":"Hover","url":"/libraries/api/Hover#update","content":"&lt;/&gt; Hover:update( deltaTime: number, speed: number, hoverAmplitude: number ) → () Updates the hover effect. deltaTime is a measure of how fast the hover effect is updated per frame, along with speed. hoverAmplitude is a measure of how much the hover effect is applied on each axis. note If the hover effect is paused, then this method will not do anything.  "},{"title":"setForces​","type":1,"pageTitle":"Hover","url":"/libraries/api/Hover#setForces","content":"&lt;/&gt; Hover:setForces( x: number?, y: number?, z: number? ) → () Sets the forces of the hover object to x, y and z.  "},{"title":"vector​","type":1,"pageTitle":"Hover","url":"/libraries/api/Hover#vector","content":"&lt;/&gt; Hover:vector() → Vector3  Returns the vector used in implementing the actual hover effect. note If the hover effect is paused, then this method will return Vector3.zero. local hover = Hover.new(0, 1, 0) local originalPosition = part.Position RunService.Stepped:Connect(function(_, deltaTime) hover:update(deltaTime, 0.5, 1) part.Position = originalPosition + hover:vector() end)   "},{"title":"destroy​","type":1,"pageTitle":"Hover","url":"/libraries/api/Hover#destroy","content":"&lt;/&gt; Hover:destroy() → () Destroys the hover object and renders it unusable. "},{"title":"infoTypeUtil","type":0,"sectionRef":"#","url":"/libraries/api/infoTypeUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"infoTypeUtil","url":"/libraries/api/infoTypeUtil#functions","content":" "},{"title":"transformedInfoTypeName​","type":1,"pageTitle":"infoTypeUtil","url":"/libraries/api/infoTypeUtil#transformedInfoTypeName","content":"&lt;/&gt; infoTypeUtil.transformedInfoTypeName(infoType: Enum.InfoType) → () Returns the transformed info type name from the given infoType or else infoType.Name. "},{"title":"instanceReplicationUtil","type":0,"sectionRef":"#","url":"/libraries/api/instanceReplicationUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"instanceReplicationUtil","url":"/libraries/api/instanceReplicationUtil#functions","content":" "},{"title":"storeInstanceSnapshot​","type":1,"pageTitle":"instanceReplicationUtil","url":"/libraries/api/instanceReplicationUtil#storeInstanceSnapshot","content":"&lt;/&gt; instanceReplicationUtil.storeInstanceSnapshot(instance: Instance ) → () This method will capture the &quot;snapshot&quot; of instance and store it within the instance it self via attributes. This method is to be used in conjuction with instanceReplicationUtil.instanceSnaphot.  "},{"title":"instanceSnaphot​","type":1,"pageTitle":"instanceReplicationUtil","url":"/libraries/api/instanceReplicationUtil#instanceSnaphot","content":"&lt;/&gt; instanceReplicationUtil.instanceSnaphot(instance: Instance ) → Promise&lt;&gt; Returns a promise which is resolved once instance has it's snapshot available. Instance snapshot required This method will throw an error if instanceUtil.storeInstanceSnapshot has not been called on instance! Waiting for an instance's descendants on the client This utility module comes in handy in cases where the client has access to some instance but with no guarantee whether it has fully replicated by the server or not. We can quite easily solve this problem! First we'll have the server store the snapshot of the instance within the instance it self: instanceReplicationUtil.storeInstanceSnapshot(workspace.Model) Then on the client, we'll simply wait for the instance's snapshot to be available: instanceReplicationUtil.instanceSnaphot(workspace.Model):andThen(function() -- At this point, you can safely access everything within workspace.Model! print(workspace.Model.SomeChild) end) Known Limitations a) storeInstanceSnapshot stores the snapshot of the given instance within the instance it self, through attributes. This means that at any point, the instance can simply have its attributes cleared away (e.g by the developer) which will break the implementation, however do note that this will usually be a sign of developer error, so you need to be careful with this! b) You need to ensure that the server calls storeInstanceSnapshot on the given instance before the client actually uses instanceSnaphot to wait for the replication of the instance's snapshot, since instanceSnaphot expects the given instance to have it's snapshot stored within the instance already. c) There is a limit as to how many attributes an instance can have, however the limit is very large so this is really nothing to worry about.  "},{"title":"instanceTagUtil","type":0,"sectionRef":"#","url":"/libraries/api/instanceTagUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"instanceTagUtil","url":"/libraries/api/instanceTagUtil#functions","content":" "},{"title":"observe​","type":1,"pageTitle":"instanceTagUtil","url":"/libraries/api/instanceTagUtil#observe","content":"&lt;/&gt; instanceTagUtil.observe( tag: string, callbackAdded: (instance: Instance ) → (), callbackRemoved: ((instance: Instance ) → ())? ) → () Observes the given CollectionService tag. callbackAdded will be automatically called on all instances with the given tag, and callbackRemoved (if specified) will be automatically called on an instance whenever it no longer has the given tag. instanceTagUtil.observe(&quot;SomeTag&quot;, function(instanceAdded) end, function(instanceRemoved) end)   "},{"title":"instanceTagPromise​","type":1,"pageTitle":"instanceTagUtil","url":"/libraries/api/instanceTagUtil#instanceTagPromise","content":"&lt;/&gt; instanceTagUtil.instanceTagPromise( instance: Instance , tag: string ) → () Returns a promise which is resolved when the given instance has the passed tag. The returned promise will be cancelled if instance is destroyed. instanceTagUtil.instanceTagPromise(instance, &quot;SomeTag&quot;, function() print(instance.Name, &quot;has tag 'SomeTag'&quot;) end)  "},{"title":"lightingUtil","type":0,"sectionRef":"#","url":"/libraries/api/lightingUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"lightingUtil","url":"/libraries/api/lightingUtil#functions","content":" "},{"title":"setSky​","type":1,"pageTitle":"lightingUtil","url":"/libraries/api/lightingUtil#setSky","content":"&lt;/&gt; lightingUtil.setSky(sky: Sky ) → () Sets the sky of Lighting by first destroying all Sky objects in it and then cloning sky into it. "},{"title":"instanceTranslationUtil","type":0,"sectionRef":"#","url":"/libraries/api/instanceTranslationUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"instanceTranslationUtil","url":"/libraries/api/instanceTranslationUtil#functions","content":" "},{"title":"tweenInstanceToCFrame​","type":1,"pageTitle":"instanceTranslationUtil","url":"/libraries/api/instanceTranslationUtil#tweenInstanceToCFrame","content":"&lt;/&gt; instanceTranslationUtil.tweenInstanceToCFrame( instance: BasePart | Model , tweenInfo: TweenInfo , result: CFrame ) → Tween  Tweens the CFrame of the given instance to result CFrame, using Instance:PivotTo. instanceTranslationUtil.tweenInstanceToCFrame(someModel, TweenInfo.new(1), {CFrame = CFrame.new(0,100,0)}) https://devforum.roblox.com/t/is-there-any-way-i-can-tween-pivotto/1918057/2 "},{"title":"Matcher","type":0,"sectionRef":"#","url":"/libraries/api/Matcher","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"Matcher","url":"/libraries/api/Matcher#functions","content":" "},{"title":"_matchers_for_search​","type":1,"pageTitle":"Matcher","url":"/libraries/api/Matcher#_matchers_for_search","content":"&lt;/&gt; Matcher:_matchers_for_search(search_string: string) → {(string) → number?} Creates matches for the specified search "},{"title":"CustomAnimator","type":0,"sectionRef":"#","url":"/libraries/api/CustomAnimator","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"CustomAnimator","url":"/libraries/api/CustomAnimator#types","content":" "},{"title":"CustomAnimator​","type":1,"pageTitle":"CustomAnimator","url":"/libraries/api/CustomAnimator#CustomAnimator","content":"&lt;/&gt; type CustomAnimator = CustomAnimator  "},{"title":"Functions​","type":1,"pageTitle":"CustomAnimator","url":"/libraries/api/CustomAnimator#functions","content":" "},{"title":"new​","type":1,"pageTitle":"CustomAnimator","url":"/libraries/api/CustomAnimator#new","content":"&lt;/&gt; CustomAnimator.new(animator: Animator | AnimationController ) → CustomAnimator Creates and returns a new custom animator object.  "},{"title":"animationTrack​","type":1,"pageTitle":"CustomAnimator","url":"/libraries/api/CustomAnimator#animationTrack","content":"&lt;/&gt; CustomAnimator:animationTrack(animation: Animation ) → AnimationTrack?  Returns the given loaded animation track from the animation, if found.  "},{"title":"onAnimationLoadPromise​","type":1,"pageTitle":"CustomAnimator","url":"/libraries/api/CustomAnimator#onAnimationLoadPromise","content":"&lt;/&gt; CustomAnimator:onAnimationLoadPromise(animation: Animation ) → () Returns a promise which is resolved once the given animation is loaded via CustomAnimator:loadAnimation.  "},{"title":"loadAnimation​","type":1,"pageTitle":"CustomAnimator","url":"/libraries/api/CustomAnimator#loadAnimation","content":"&lt;/&gt; CustomAnimator:loadAnimation(animation: Animation ) → AnimationTrack  Loads in the animation as an animation track.  "},{"title":"playAnimation​","type":1,"pageTitle":"CustomAnimator","url":"/libraries/api/CustomAnimator#playAnimation","content":"&lt;/&gt; CustomAnimator:playAnimation( animation: Animation , fadeTime: number?, weight: number?, speed: number? ) → AnimationTrack  Plays the given animation, if it has been loaded into the animator object via CustomAnimator:loadAnimation. tip You can also setup attributes for fadeTime, weight, and speed in the animation object, which will be used incase the arguments aren't specified. fadeTime -&gt; FadeTime weight -&gt; Weight speed -&gt; Speed  "},{"title":"stopAnimation​","type":1,"pageTitle":"CustomAnimator","url":"/libraries/api/CustomAnimator#stopAnimation","content":"&lt;/&gt; CustomAnimator:stopAnimation( animation: Animation , fadeTime: number? ) → AnimationTrack  Stops the given animation, if it has been loaded into the animator object via CustomAnimator:loadAnimation. tip You can also setup an attribute for fadeTime in the animation object, which will be used incase the argument isn't specified. fadeTime -&gt; FadeTime  "},{"title":"stopAll​","type":1,"pageTitle":"CustomAnimator","url":"/libraries/api/CustomAnimator#stopAll","content":"&lt;/&gt; CustomAnimator:stopAll(fadeTime: number?) → () Stops all loaded animations by calling CustomAnimator:stopAnimation on each loaded animation.  "},{"title":"all​","type":1,"pageTitle":"CustomAnimator","url":"/libraries/api/CustomAnimator#all","content":"&lt;/&gt; CustomAnimator:all() → {[Animation ]: AnimationTrack } Returns a read only array of all animations loaded into the animator object.  "},{"title":"cleanupAnimationTrack​","type":1,"pageTitle":"CustomAnimator","url":"/libraries/api/CustomAnimator#cleanupAnimationTrack","content":"&lt;/&gt; CustomAnimator:cleanupAnimationTrack(animation: Animation ) → () Stops the given animation track if loaded, and destroys it.  "},{"title":"animator​","type":1,"pageTitle":"CustomAnimator","url":"/libraries/api/CustomAnimator#animator","content":"&lt;/&gt; CustomAnimator:animator() → Animator  Returns the animator associated to the animator object.  "},{"title":"destroy​","type":1,"pageTitle":"CustomAnimator","url":"/libraries/api/CustomAnimator#destroy","content":"&lt;/&gt; CustomAnimator:destroy() → () Destroys the custom animator object and renders it unusuable. Additionally, CustomAnimator:cleanupAnimationTrack is called on all loaded animation tracks too. "},{"title":"ContentProviderQueue","type":0,"sectionRef":"#","url":"/libraries/api/ContentProviderQueue","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"ContentProviderQueue","url":"/libraries/api/ContentProviderQueue#types","content":" "},{"title":"ContentProviderQueue​","type":1,"pageTitle":"ContentProviderQueue","url":"/libraries/api/ContentProviderQueue#ContentProviderQueue","content":"&lt;/&gt; type ContentProviderQueue = ContentProviderQueue  "},{"title":"Properties​","type":1,"pageTitle":"ContentProviderQueue","url":"/libraries/api/ContentProviderQueue#properties","content":" "},{"title":"onInstancePreloaded​","type":1,"pageTitle":"ContentProviderQueue","url":"/libraries/api/ContentProviderQueue#onInstancePreloaded","content":"Read only Signal ContentProviderQueue Instance &lt;/&gt; ContentProviderQueue.onInstancePreloaded: Signal&lt;instance: Instance, contentProviderId: string,deltaTime: number,status: Enum.AssetFetchStatus&gt; A signal which is fired whenever an instance in the content provider queue has been preloaded. deltaTime is the amount of time the instance took to be preloaded.  "},{"title":"onInstancePreloading​","type":1,"pageTitle":"ContentProviderQueue","url":"/libraries/api/ContentProviderQueue#onInstancePreloading","content":"Read only Signal ContentProviderQueue Instance &lt;/&gt; ContentProviderQueue.onInstancePreloading: Signal&lt;instance: Instance &gt; A signal which is fired whenever an instance in the content provider queue is being preloaded.  "},{"title":"onInstanceAdded​","type":1,"pageTitle":"ContentProviderQueue","url":"/libraries/api/ContentProviderQueue#onInstanceAdded","content":"Read only Signal ContentProviderQueue Instance &lt;/&gt; ContentProviderQueue.onInstanceAdded: Signal&lt;instance: Instance &gt; A signal which is fired whenever an instance is added to the content provider queue.  "},{"title":"onInstanceRemoved​","type":1,"pageTitle":"ContentProviderQueue","url":"/libraries/api/ContentProviderQueue#onInstanceRemoved","content":"Read only Signal ContentProviderQueue Instance &lt;/&gt; ContentProviderQueue.onInstanceRemoved: Signal&lt;instance: Instance &gt; A signal which is fired whenever an instance is removed from the content provider queue. "},{"title":"Functions​","type":1,"pageTitle":"ContentProviderQueue","url":"/libraries/api/ContentProviderQueue#functions","content":" "},{"title":"new​","type":1,"pageTitle":"ContentProviderQueue","url":"/libraries/api/ContentProviderQueue#new","content":"&lt;/&gt; ContentProviderQueue.new(initialUpdateInterval: number?) → ContentProviderQueue Creates a new content preloader queue. An initialUpdateInterval argument can be passed as the initial update interval of the queue.  "},{"title":"setUpdateInterval​","type":1,"pageTitle":"ContentProviderQueue","url":"/libraries/api/ContentProviderQueue#setUpdateInterval","content":"&lt;/&gt; ContentProviderQueue:setUpdateInterval(updateInterval: number) → () Sets the update interval of the queue, i.e the interval at which the queue will preload each asset.  "},{"title":"add​","type":1,"pageTitle":"ContentProviderQueue","url":"/libraries/api/ContentProviderQueue#add","content":"&lt;/&gt; ContentProviderQueue:add(instance: Instance ) → () Adds the given instance to the content provider queue. If the given instance already exists, then the instance will not be readded again.  "},{"title":"addInstances​","type":1,"pageTitle":"ContentProviderQueue","url":"/libraries/api/ContentProviderQueue#addInstances","content":"&lt;/&gt; ContentProviderQueue:addInstances(instances: {Instance }) → () Adds all instances in instances to the content provider queue, via ContentProviderQueue:add.  "},{"title":"remove​","type":1,"pageTitle":"ContentProviderQueue","url":"/libraries/api/ContentProviderQueue#remove","content":"&lt;/&gt; ContentProviderQueue:remove(instance: Instance ) → () Removes the instance from the given queue, if the instance was being preloaded, then it will be disregarded by the content provider queue. local contentProviderQueue = ... contentProviderQueue:add(sound1) print(#contentProviderQueue:pendingInstances()) --&gt; 1 contentProviderQueue:remove(sound1) print(pendingInstancescontentProviderQueue:pendingInstances()) --&gt; 0   "},{"title":"progress​","type":1,"pageTitle":"ContentProviderQueue","url":"/libraries/api/ContentProviderQueue#progress","content":"&lt;/&gt; ContentProviderQueue:progress() → number Returns a number from 0 to 1 indicating the progress of the content provider queue (i.e ratio of how many instances have been preloaded versus how many instances are yet to be preloaded).  "},{"title":"fullyProgressed​","type":1,"pageTitle":"ContentProviderQueue","url":"/libraries/api/ContentProviderQueue#fullyProgressed","content":"&lt;/&gt; ContentProviderQueue:fullyProgressed() → Promise&lt;&gt; Returns a promise which is resolved once the content provider queue has fully progressed, i.e there are no more instances to preload.  "},{"title":"paused​","type":1,"pageTitle":"ContentProviderQueue","url":"/libraries/api/ContentProviderQueue#paused","content":"&lt;/&gt; ContentProviderQueue:paused() → boolean Returns a boolean indicating if the content provider queue is paused or not.  "},{"title":"resume​","type":1,"pageTitle":"ContentProviderQueue","url":"/libraries/api/ContentProviderQueue#resume","content":"&lt;/&gt; ContentProviderQueue:resume() → () Resumes the content provider queue.  "},{"title":"pause​","type":1,"pageTitle":"ContentProviderQueue","url":"/libraries/api/ContentProviderQueue#pause","content":"&lt;/&gt; ContentProviderQueue:pause() → () Pauses the content provider queue. If any more instances are to be preloaded, they won't be until the content provider object is resumed back.  "},{"title":"empty​","type":1,"pageTitle":"ContentProviderQueue","url":"/libraries/api/ContentProviderQueue#empty","content":"&lt;/&gt; ContentProviderQueue:empty() → () Clears all instances to be preloaded from the content provider queue, via ContentProviderQueue:remove.  "},{"title":"pendingInstances​","type":1,"pageTitle":"ContentProviderQueue","url":"/libraries/api/ContentProviderQueue#pendingInstances","content":"&lt;/&gt; ContentProviderQueue:pendingInstances() → {Instance } Returns a read only array of all instances, yet to be preloaded in the content provider queue.  "},{"title":"destroy​","type":1,"pageTitle":"ContentProviderQueue","url":"/libraries/api/ContentProviderQueue#destroy","content":"&lt;/&gt; ContentProviderQueue:destroy() → () Destroys the content provider queue, empties it through ContentProviderQueue:empty and renders it unusable. "},{"title":"instanceAttributeUtil","type":0,"sectionRef":"#","url":"/libraries/api/instanceAttributeUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"instanceAttributeUtil","url":"/libraries/api/instanceAttributeUtil#functions","content":" "},{"title":"all​","type":1,"pageTitle":"instanceAttributeUtil","url":"/libraries/api/instanceAttributeUtil#all","content":"&lt;/&gt; instanceAttributeUtil.all( instanceTree: Instance , desiredAttribute: string ) → () Returns a read only array of all descendants in instanceTree which have the desiredAttribute attribute.  "},{"title":"observeMany​","type":1,"pageTitle":"instanceAttributeUtil","url":"/libraries/api/instanceAttributeUtil#observeMany","content":"&lt;/&gt; instanceAttributeUtil.observeMany( instance: Instance , attributesToObserve: {[string]: any}, observer: Observer ) → RBXScriptConnection  Works similar to instanceAttributeUtil.observe, but observes an dictionary of attributes instead of a single attribute. Returns a RBXScriptConnection object. instanceAttributeUtil.observeMany(workspace, workspace:GetAttributes(), function(newAttributes, oldAttributes) ... end)   "},{"title":"new​","type":1,"pageTitle":"instanceAttributeUtil","url":"/libraries/api/instanceAttributeUtil#new","content":"&lt;/&gt; instanceAttributeUtil.new( instanceTree: Instance , desiredAttribute: string, callback: (descendant: Instance ) → () ) → RBXScriptConnection  Sets up an event connection which listens to any descendant added to instanceTree, if it has the desiredAttribute atribute, then callback will be called. Returns a RBXScriptConnection object. instanceAttributeUtil.new(workspace, &quot;Test&quot;, function(instance) print(instance) end)   "},{"title":"removed​","type":1,"pageTitle":"instanceAttributeUtil","url":"/libraries/api/instanceAttributeUtil#removed","content":"&lt;/&gt; instanceAttributeUtil.removed( instanceTree: Instance , desiredAttribute: string, callback: (descendant: Instance ) → () ) → RBXScriptConnection  Sets up an event connection which listens to any descendant removed from instanceTree, if it has the desiredAttribute atribute, then callback will be called. Returns a RBXScriptConnection object. instanceAttributeUtil.removed(workspace, &quot;Test&quot;, function(instance) print(instance) end)   "},{"title":"observe​","type":1,"pageTitle":"instanceAttributeUtil","url":"/libraries/api/instanceAttributeUtil#observe","content":"&lt;/&gt; instanceAttributeUtil.observe( instance: Instance , desiredAttribute: string, observer: Observer ) → ( RBXScriptConnection , any ) Observes the value of attribute desiredAttribute in instance, so observer is called every time the attribute updates. Returns a RBXScriptConnection object, as well a promise that is resolved when observer is called for the first time and has finished running. instanceAttributeUtil.observe(workspace, &quot;SomeAttribute&quot;, function(newValue, oldValue) ... end)   "},{"title":"instanceAttributePromise​","type":1,"pageTitle":"instanceAttributeUtil","url":"/libraries/api/instanceAttributeUtil#instanceAttributePromise","content":"&lt;/&gt; instanceAttributeUtil.instanceAttributePromise( instance: Instance , attribute: string, predicate: (( newValue: any, oldValue: any ) → boolean)? ) → () Returns a promise which is resolved when the given instance has the given attribute. instanceAttributeUtil.instanceAttributePromise(instance, &quot;SomeAttribute&quot;):andThen(function(value) print(value) --&gt; 5 end) instance:SetAttribute(&quot;SomeAttribute&quot;, 5) predicate can also be passed, which should return a boolean value. It is passed the new attribute value of the instance, and the old attribute value of the instance. The promise will only resolve when predicate returns true for the new attribute value of the instance. The returned promise will be cancelled if instance is destroyed. instanceAttributeUtil.instanceAttributePromise(instance, &quot;SomeAttribute&quot;, function(newValue, oldValue) return newValue == 2 and oldValue == 1 end):andThen(function(value) print(value) --&gt; 2 end) instance:SetAttribute(&quot;SomeAttribute&quot;, 1) instance:SetAttribute(&quot;SomeAttribute&quot;, 2)   "},{"title":"instanceAttributesPromise​","type":1,"pageTitle":"instanceAttributeUtil","url":"/libraries/api/instanceAttributeUtil#instanceAttributesPromise","content":"&lt;/&gt; instanceAttributeUtil.instanceAttributesPromise( instance: Instance , attributes: {string} ) → Promise&lt;&gt; Calls instanceAttributeUtil.instanceAttributePromise for every attribute in attributes, and saves the promise internally. Returns a promise that is reolved once all internal promises have been resolved. "},{"title":"Component","type":0,"sectionRef":"#","url":"/libraries/api/Component","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Component","url":"/libraries/api/Component#types","content":" "},{"title":"ExtensionFn​","type":1,"pageTitle":"Component","url":"/libraries/api/Component#ExtensionFn","content":"&lt;/&gt; type ExtensionFn = (component) → ()   "},{"title":"ExtensionShouldFn​","type":1,"pageTitle":"Component","url":"/libraries/api/Component#ExtensionShouldFn","content":"&lt;/&gt; type ExtensionShouldFn = (component) → boolean   "},{"title":"Extension​","type":1,"pageTitle":"Component","url":"/libraries/api/Component#Extension","content":"&lt;/&gt; interface Extension { shouldExtend: ExtensionShouldFn? shouldConstruct: ExtensionShouldFn? constructing: ExtensionFn? constructed: ExtensionFn? starting: ExtensionFn? started: ExtensionFn? stopping: ExtensionFn? stopped: ExtensionFn? } An extension allows the ability to extend the behavior of components. This is useful for adding injection systems or extending the behavior of components by wrapping around component lifecycle methods. The shouldConstruct function can be used to indicate if the component should actually be created. This must return true or false. A component with multiple shouldConstruct extension functions must have them all return true in order for the component to be constructed. The shouldConstruct function runs before all other extension functions and component lifecycle methods. The shouldExtend function can be used to indicate if the extension itself should be used. This can be used in order to toggle an extension on/off depending on whatever logic is appropriate. If no shouldExtend function is provided, the extension will always be used if provided as an extension to the component. As an example, an extension could be created to simply log when the various lifecycle stages run on the component: local Logger = {} function Logger.constructing(component, componentClass) print(&quot;constructing&quot;, component) end function Logger.constructed(component, componentClass) print(&quot;constructed&quot;, component) end function Logger.starting(component, componentClass) print(&quot;starting&quot;, component) end function Logger.started(component, componentClass) print(&quot;started&quot;, component) end function Logger.stopping(component, componentClass) print(&quot;stopping&quot;, component) end function Logger.stopped(component, componentClass) print(&quot;stopped&quot;, component) end local MyComponent = Component.new({tag = &quot;MyComponent&quot;, extensions = {Logger}}) Sometimes it is useful for an extension to control whether or not a component should be constructed. For instance, if a component on the client should only be instantiated for the local player, an extension might look like this, assuming the instance has an attribute linking it to the player's UserId: local player = game:GetService(&quot;Players&quot;).LocalPlayer local OnlyLocalPlayer = {} function OnlyLocalPlayer.shouldConstruct(component) local ownerId = component.instance:GetAttribute(&quot;OwnerId&quot;) return ownerId == player.UserId end local MyComponent = Component.new({tag = &quot;MyComponent&quot;, extensions = {OnlyLocalPlayer}}) It can also be useful for an extension itself to turn on/off depending on various contexts. For example, let's take the Logger from the first example, and only use that extension if the bound instance has a Log attribute set to true: function Logger.shouldExtend(component) return component.instance:GetAttribute(&quot;Log&quot;) == true end   "},{"title":"ComponentConfig​","type":1,"pageTitle":"Component","url":"/libraries/api/Component#ComponentConfig","content":"&lt;/&gt; interface ComponentConfig { tag: string-- CollectionService tag to use ancestors: {Instance }?-- Optional array of ancestors in which components will be started extensions: {Extension}?-- Optional array of extension objects } Component configuration passed to Component.new. If no ancestors option is included, it defaults to {workspace, game.Players}. If no extensions option is included, it defaults to a blank table {}. "},{"title":"Properties​","type":1,"pageTitle":"Component","url":"/libraries/api/Component#properties","content":" "},{"title":"started​","type":1,"pageTitle":"Component","url":"/libraries/api/Component#started","content":"Event Component Class &lt;/&gt; Component.started: Signal Fired when a new instance of a component is started. local MyComponent = Component.new({tag = &quot;MyComponent&quot;}) MyComponent.started:Connect(function(component) end)   "},{"title":"stopped​","type":1,"pageTitle":"Component","url":"/libraries/api/Component#stopped","content":"Event Component Class &lt;/&gt; Component.stopped: Signal Fired when an instance of a component is stopped. local MyComponent = Component.new({tag = &quot;MyComponent&quot;}) MyComponent.stopped:Connect(function(component) end)   "},{"title":"instance​","type":1,"pageTitle":"Component","url":"/libraries/api/Component#instance","content":"Component Instance &lt;/&gt; Component.instance: Instance  A reference back to the Roblox instance from within a component instance. When a component instance is created, it is bound to a specific Roblox instance, which will always be present through the Instance property. MyComponent.started:Connect(function(component) local robloxInstance: Instance = component.instance print(&quot;Component is bound to &quot; .. robloxInstance:GetFullName()) end)  "},{"title":"Functions​","type":1,"pageTitle":"Component","url":"/libraries/api/Component#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Component","url":"/libraries/api/Component#new","content":"Component &lt;/&gt; Component.new(config: ComponentConfig) → ComponentClass Create a new custom Component class. local MyComponent = Component.new({tag = &quot;MyComponent&quot;}) A full example might look like this: local MyComponent = Component.new({ tag = &quot;MyComponent&quot;, ancestors = {workspace}, extensions = {Logger}, -- See Logger example within the example for the Extension type }) local AnotherComponent = require(somewhere.AnotherComponent) -- Optional if UpdateRenderStepped should use BindToRenderStep: MyComponent.RenderPriority = Enum.RenderPriority.Camera.Value function MyComponent:construct() self.MyData = &quot;Hello&quot; end function MyComponent:start() local another = self:component(AnotherComponent) another:DoSomething() end function MyComponent:stop() self.MyData = &quot;Goodbye&quot; end function MyComponent:heartbeatUpdate(dt) end function MyComponent:steppedUpdate(time, dt) end function MyComponent:renderSteppedUpdate(dt) end   "},{"title":"heartbeatUpdate​","type":1,"pageTitle":"Component","url":"/libraries/api/Component#heartbeatUpdate","content":"Component Class &lt;/&gt; Component.heartbeatUpdate(dt: number) → () If this method is present on a component, then it will be automatically connected to RunService.Heartbeat. Method This is a method, not a function. This is a limitation of the documentation tool which should be fixed soon. local MyComponent = Component.new({tag = &quot;MyComponent&quot;}) function MyComponent:heartbeatUpdate(dt) end   "},{"title":"steppedUpdate​","type":1,"pageTitle":"Component","url":"/libraries/api/Component#steppedUpdate","content":"Component Class &lt;/&gt; Component.steppedUpdate( time: number, dt: number ) → () If this method is present on a component, then it will be automatically connected to RunService.Stepped. Method This is a method, not a function. This is a limitation of the documentation tool which should be fixed soon. local MyComponent = Component.new({tag = &quot;MyComponent&quot;}) function MyComponent:steppedUpdate(time, dt) end   "},{"title":"renderSteppedUpdate​","type":1,"pageTitle":"Component","url":"/libraries/api/Component#renderSteppedUpdate","content":"This item only works when running on the client. Client Component Class &lt;/&gt; Component.renderSteppedUpdate(dt: number) → () If this method is present on a component, then it will be automatically connected to RunService.RenderStepped. If the [Component].RenderPriority field is found, then the component will instead use RunService:BindToRenderStep() to bind the function. Method This is a method, not a function. This is a limitation of the documentation tool which should be fixed soon. -- Example that uses `RunService.RenderStepped` automatically: local MyComponent = Component.new({tag = &quot;MyComponent&quot;}) function MyComponent:renderSteppedUpdate(dt) end -- Example that uses `RunService:BindToRenderStep` automatically: local MyComponent = Component.new({tag = &quot;MyComponent&quot;}) -- Defining a RenderPriority will force the component to use BindToRenderStep instead MyComponent.RenderPriority = Enum.RenderPriority.Camera.Value function MyComponent:renderSteppedUpdate(dt) end   "},{"title":"all​","type":1,"pageTitle":"Component","url":"/libraries/api/Component#all","content":"Component Class &lt;/&gt; Component:all() → {Component} Gets a table array of all existing component objects. For example, if there was a component class linked to the &quot;MyComponent&quot; tag, and three Roblox instances in your game had that same tag, then calling all would return the three component instances. local MyComponent = Component.new({tag = &quot;MyComponent&quot;}) -- ... local components = MyComponent:all() for _,component in components do component:DoSomethingHere() end   "},{"title":"fromInstance​","type":1,"pageTitle":"Component","url":"/libraries/api/Component#fromInstance","content":"Component Class &lt;/&gt; Component:fromInstance(instance: Instance ) → Component? Gets an instance of a component class from the given Roblox instance. Returns nil if not found. local MyComponent = require(somewhere.MyComponent) local myComponentInstance = MyComponent:fromInstance(workspace.SomeInstance)   "},{"title":"waitForInstance​","type":1,"pageTitle":"Component","url":"/libraries/api/Component#waitForInstance","content":"Component Class &lt;/&gt; Component:waitForInstance( instance: Instance , timeout: number? ) → Promise&lt;ComponentInstance&gt; Resolves a promise once the component instance is present on a given Roblox instance. An optional timeout can be provided to reject the promi se if it takes more than timeout seconds to resolve. If no timeout is supplied, timeout defaults to 60 seconds. local MyComponent = require(somewhere.MyComponent) MyComponent:waitForInstance(workspace.SomeInstance):andThen(function(myComponentInstance) -- Do something with the component class end)   "},{"title":"construct​","type":1,"pageTitle":"Component","url":"/libraries/api/Component#construct","content":"Component Class &lt;/&gt; Component:construct() → () construct is called before the component is started, and should be used to construct the component instance. Cancellation If this method has not yet finished when the component instance is stopped, then it will be forcefuly stopped. local MyComponent = Component.new({tag = &quot;MyComponent&quot;}) function MyComponent:construct() self.SomeData = 32 self.OtherStuff = &quot;HelloWorld&quot; end   "},{"title":"start​","type":1,"pageTitle":"Component","url":"/libraries/api/Component#start","content":"Component Class &lt;/&gt; Component:start() → () start is called when the component is started, and all other component instances of the instance bound to the component are ready. At this point in time, it is safe to grab other components also bound to the same instance. Cancellation If this method has not yet finished when the component instance is stopped, then it will be forcefuly stopped. local MyComponent = Component.new({tag = &quot;MyComponent&quot;}) local AnotherComponent = require(somewhere.AnotherComponent) function MyComponent:start() -- e.g., grab another component: local another = self:component(AnotherComponent) end   "},{"title":"stop​","type":1,"pageTitle":"Component","url":"/libraries/api/Component#stop","content":"Component Class &lt;/&gt; Component:stop() → () stop is called when the component is stopped. This occurs either when the bound instance is removed from one of the whitelisted ancestors or when the matching tag is removed from the instance. This also means that the instance might be destroyed, and thus it is not safe to continue using the bound instance (e.g. self.instance) any longer. This should be used to clean up the component. local MyComponent = Component.new({tag = &quot;MyComponent&quot;}) function MyComponent:stop() self.SomeStuff:destroy() end   "},{"title":"component​","type":1,"pageTitle":"Component","url":"/libraries/api/Component#component","content":"Component Instance &lt;/&gt; Component:component(componentClass: ComponentClass) → Component? Retrieves another component instance bound to the same Roblox instance. local MyComponent = Component.new({tag = &quot;MyComponent&quot;}) local AnotherComponent = require(somewhere.AnotherComponent) function MyComponent:start() local another = self:component(AnotherComponent) end  "},{"title":"marketPlaceServiceUtil","type":0,"sectionRef":"#","url":"/libraries/api/marketPlaceServiceUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"marketPlaceServiceUtil","url":"/libraries/api/marketPlaceServiceUtil#functions","content":" "},{"title":"productInfo​","type":1,"pageTitle":"marketPlaceServiceUtil","url":"/libraries/api/marketPlaceServiceUtil#productInfo","content":"&lt;/&gt; marketPlaceServiceUtil.productInfo( assetId: number, infoType: Enum.InfoType? ) → Promise&lt;ProductInfo&gt; Returns a promise which is resolved wih the product info of the given place id.  "},{"title":"userOwnsGamepassAsync​","type":1,"pageTitle":"marketPlaceServiceUtil","url":"/libraries/api/marketPlaceServiceUtil#userOwnsGamepassAsync","content":"&lt;/&gt; marketPlaceServiceUtil.userOwnsGamepassAsync( userId: number, gamepassId: number ) → Promise&lt;boolean&gt; Returns a promise which is resolved with a boolean indicating if the user owns the specified gamepass or not. Incase the operation fails, the promise will reject with an additional value i.e the error message. local wasSucessfull, userOwnsGamepass, errorMessage = marketPlaceServiceUtil.userOwnsGamepassAsync(123, 45678123):await() if wasSucessfull then print(userOwnsGamepass) else print(userOwnsGamepass) --&gt; false print(errorMessage) end   "},{"title":"playerOwnsAsset​","type":1,"pageTitle":"marketPlaceServiceUtil","url":"/libraries/api/marketPlaceServiceUtil#playerOwnsAsset","content":"&lt;/&gt; marketPlaceServiceUtil.playerOwnsAsset( player: Player , assetId: number ) → Promise&lt;boolean&gt; Returns a promise which is resolved with a boolean indicating if the player owns the specified asset or not. Incase the operation fails, the promise will reject with an additional value i.e the error message. local wasSucessfull, playerOwnsAsset, errorMessage = marketPlaceServiceUtil.playerOwnsAsset(123, 45678123):await() if wasSucessfull then print(playerOwnsAsset) else print(playerOwnsAsset) --&gt; false print(errorMessage) end   "},{"title":"playerOwnsBundle​","type":1,"pageTitle":"marketPlaceServiceUtil","url":"/libraries/api/marketPlaceServiceUtil#playerOwnsBundle","content":"&lt;/&gt; marketPlaceServiceUtil.playerOwnsBundle( player: Player , bundleId: number ) → Promise&lt;boolean&gt; Returns a promise which is resolved with a boolean indicating if the player owns the specified bundle or not. Incase the operation fails, the promise will reject with an additional value i.e the error message. local wasSucessfull, playerOwnsBundle, errorMessage = marketPlaceServiceUtil.playerOwnsBundle(123, 45678123):await() if wasSucessfull then print(playerOwnsBundle) else print(playerOwnsBundle) --&gt; false print(errorMessage) end   "},{"title":"subscriptionInfoProductAsync​","type":1,"pageTitle":"marketPlaceServiceUtil","url":"/libraries/api/marketPlaceServiceUtil#subscriptionInfoProductAsync","content":"&lt;/&gt; marketPlaceServiceUtil.subscriptionInfoProductAsync(subscriptionId: string) → Promise&lt;SubscriptionInfo&gt; Returns a promise which is resolved with the info of the given subscription id. local wasSucessfull, subscriptionInfo = marketPlaceServiceUtil.subscriptionInfoProductAsync(subscriptionId):await() if wasSucessfull then print(subscriptionInfo) else print(tostring(subscriptionInfo)) -- Error end   "},{"title":"userSubscriptionDetailsAsync​","type":1,"pageTitle":"marketPlaceServiceUtil","url":"/libraries/api/marketPlaceServiceUtil#userSubscriptionDetailsAsync","content":"&lt;/&gt; marketPlaceServiceUtil.userSubscriptionDetailsAsync( player: Player , subscriptionId: string ) → Promise&lt;UserSubscriptionDetails&gt; Returns a promise which is resolved with the user subscription details. local wasSucessfull, userSubscriptionDetails = marketPlaceServiceUtil.GetUserSubscriptionDetailsAsync(player, subscriptionId):await() if wasSucessfull then print(userSubscriptionDetails) else print(tostring(userSubscriptionDetails)) -- Error end   "},{"title":"userSubscriptionPaymentHistoryAsync​","type":1,"pageTitle":"marketPlaceServiceUtil","url":"/libraries/api/marketPlaceServiceUtil#userSubscriptionPaymentHistoryAsync","content":"&lt;/&gt; marketPlaceServiceUtil.userSubscriptionPaymentHistoryAsync( player: Player , subscriptionId: string ) → Promise&lt;UserSubscriptionPaymentHistory&gt; Returns a promise which is resolved with the user subscription payment history. local wasSucessfull, userSubscriptionPaymentHistory = marketPlaceServiceUtil.userSubscriptionPaymentHistoryAsync(player, subscriptionId):await() if wasSucessfull then print(userSubscriptionPaymentHistory) else print(tostring(userSubscriptionPaymentHistory)) -- Error end   "},{"title":"userSubscriptionStatusAsync​","type":1,"pageTitle":"marketPlaceServiceUtil","url":"/libraries/api/marketPlaceServiceUtil#userSubscriptionStatusAsync","content":"&lt;/&gt; marketPlaceServiceUtil.userSubscriptionStatusAsync( player: Player , subscriptionId: string ) → Promise&lt;UserSubscriptionStatus&gt; Returns a promise which is resolved with the user subscription payment history. local wasSucessfull, userSubscriptionStatus = marketPlaceServiceUtil.userSubscriptionStatusAsync(player, subscriptionId):await() if wasSucessfull then print(userSubscriptionStatus) else print(tostring(userSubscriptionStatus)) -- Error end   "},{"title":"activeAssetProductInfoWhichPlayerOwns​","type":1,"pageTitle":"marketPlaceServiceUtil","url":"/libraries/api/marketPlaceServiceUtil#activeAssetProductInfoWhichPlayerOwns","content":"&lt;/&gt; marketPlaceServiceUtil.activeAssetProductInfoWhichPlayerOwns( playerUserId: number, assetId: number ) → () Retrieves the asset product info that belongs to a player of userid playerUserId. "},{"title":"matterEntityUtil","type":0,"sectionRef":"#","url":"/libraries/api/matterEntityUtil","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"matterEntityUtil","url":"/libraries/api/matterEntityUtil#types","content":" "},{"title":"InstanceIdAttribute​","type":1,"pageTitle":"matterEntityUtil","url":"/libraries/api/matterEntityUtil#InstanceIdAttribute","content":"&lt;/&gt; type InstanceIdAttribute = &quot;serverEntityId&quot; | &quot;clientEntityId&quot; Is serverEntityId on the server and clientEntityId on the client. "},{"title":"Functions​","type":1,"pageTitle":"matterEntityUtil","url":"/libraries/api/matterEntityUtil#functions","content":" "},{"title":"setInstanceId​","type":1,"pageTitle":"matterEntityUtil","url":"/libraries/api/matterEntityUtil#setInstanceId","content":"&lt;/&gt; matterEntityUtil.setInstanceId( instance: Instance , id: number ) → () Sets an attribute (InstanceIdAttribute) in the given instance to id.  "},{"title":"instanceId​","type":1,"pageTitle":"matterEntityUtil","url":"/libraries/api/matterEntityUtil#instanceId","content":"&lt;/&gt; matterEntityUtil.instanceId(instance: Instance ) → number? Returns the instane attribute id of the given instance, if found.  "},{"title":"instanceIdPromise​","type":1,"pageTitle":"matterEntityUtil","url":"/libraries/api/matterEntityUtil#instanceIdPromise","content":"&lt;/&gt; matterEntityUtil.instanceIdPromise(instance: Instance ) → Promise&lt;number&gt; Returns a promise which is resolved with the entity id attribute (set by matterEntityUtil.setInstanceId) of the given instance. matterEntityUtil.instanceIdPromise(instance):andThen(function(entityId) print(typeof(entityId)) --&gt; &quot;number&quot; end)   "},{"title":"entityIdFromComponents​","type":1,"pageTitle":"matterEntityUtil","url":"/libraries/api/matterEntityUtil#entityIdFromComponents","content":"&lt;/&gt; matterEntityUtil.entityIdFromComponents( world: Matter.World, ...: Matter.Component ) → number? Returns the id of the entity which has the given components. local id = world:spawn(componentA) local entityId = matterEntityUtil.entityIdFromComponents(componentA) print(entityId == id)  "},{"title":"network","type":0,"sectionRef":"#","url":"/libraries/api/network","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"network","url":"/libraries/api/network#properties","content":" "},{"title":"Server​","type":1,"pageTitle":"network","url":"/libraries/api/network#Server","content":"Read only &lt;/&gt; network.Server: NetworkServer   "},{"title":"client​","type":1,"pageTitle":"network","url":"/libraries/api/network#client","content":"Read only &lt;/&gt; network.client: networkClient  "},{"title":"matrixUtil","type":0,"sectionRef":"#","url":"/libraries/api/matrixUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"matrixUtil","url":"/libraries/api/matrixUtil#functions","content":" "},{"title":"matchingRowsValue​","type":1,"pageTitle":"matrixUtil","url":"/libraries/api/matrixUtil#matchingRowsValue","content":"&lt;/&gt; matrixUtil.matchingRowsValue( matrix: {{T}}, depth: number? ) → T? Searches matrix row-wise, and returns a value in a row that matches with the rest of the values of that row. E.g: local matrix = { {1, 1, 1}, {5, 5, 2}, {0, 0, 2}, } print(matrixUtil.matchingRowsValue(matrix)) --&gt; 1 (The first row is equally matched (all 1s)) Additionally, you can specify depth if you want to control how far the method should check each row. For e.g: local matrix = { {1, 2, 3, 4}, {5, 6, 7, 8}, {1, 1, 1, 0}, } print(matrixUtil.matchingRowsValue(matrix, 3)) --&gt; 1 (The last row's first 3 values (1s) are equally matched) print(matrixUtil.matchingRowsValue(matrix, 4)) --&gt; nil (No row's first 4 values are equally matched)   "},{"title":"matchingDiagonalColumnsValue​","type":1,"pageTitle":"matrixUtil","url":"/libraries/api/matrixUtil#matchingDiagonalColumnsValue","content":"&lt;/&gt; matrixUtil.matchingDiagonalColumnsValue( matrix: {{T}}, depth: number? ) → T? Searches matrix diagonally, and returns a value that matches with the rest of the values of the arrays in matrix. E.g: local matrix = { {5, 0, 0}, {0, 5, 0}, {0, 0, 5}, } print(matrixUtil.matchingDiagonalColumnsValue(matrix)) --&gt; 1 (A column has matching values diagonally (just 5s)) Additionally, you can specify depth if you want to control how far the method should search matrix diagonally. For e.g: local matrix = { {2, 0, 0, 0}, {0, 2, 0, 0}, {0, 0, 2, 0}, {0, 0, 0, 0}, } print(matrix.matchingDiagonalColumnsValue(matrix, 3)) --&gt; 2 (A column has FIRST 3 matching values diagonally (just 2s))   "},{"title":"matchingColumnsValue​","type":1,"pageTitle":"matrixUtil","url":"/libraries/api/matrixUtil#matchingColumnsValue","content":"&lt;/&gt; matrixUtil.matchingColumnsValue( matrix: {{T}}, depth: number? ) → T? Searches matrix column-wise and returns a value of a column that matches with the rest of the values of that column. E.g: local matrix = { {5, 0, 0}, {5, 1, 0}, {5, 0, 1}, } print(matrixUtil.matchingColumnsValue(matrix)) --&gt; 5 (A column has ALL equally matching values (just 5s)) Additionally, you can specify depth if you want to control how far the method should check each column. For e.g: local matrix = { {5, 0, 0}, {5, 0, 0}, {2, 1, 1}, } print(matrixUtil.matchingColumnsValue(matrix, 2)) --&gt; 5 (A column has FIRST 2 matching values (just 5s))  "},{"title":"numberStringUtil","type":0,"sectionRef":"#","url":"/libraries/api/numberStringUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"numberStringUtil","url":"/libraries/api/numberStringUtil#functions","content":" "},{"title":"numberToTuple​","type":1,"pageTitle":"numberStringUtil","url":"/libraries/api/numberStringUtil#numberToTuple","content":"&lt;/&gt; numberStringUtil.numberToTuple(number: number) → string? Returns the given number's tuple, if any. Supports up to 57 tuples! print(numberStringUtil.numberToTuple(2)) --&gt; &quot;Double&quot; print(numberStringUtil.numberToTuple(3)) --&gt; &quot;Triple&quot; print(numberStringUtil.numberToTuple(4)) --&gt; &quot;Quadruple&quot;  "},{"title":"networkClient","type":0,"sectionRef":"#","url":"/libraries/api/networkClient","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"networkClient","url":"/libraries/api/networkClient#properties","content":" "},{"title":"ClientRemoteProperty​","type":1,"pageTitle":"networkClient","url":"/libraries/api/networkClient#ClientRemoteProperty","content":"Read only &lt;/&gt; networkClient.ClientRemoteProperty: ClientRemoteProperty   "},{"title":"ClientRemoteSignal​","type":1,"pageTitle":"networkClient","url":"/libraries/api/networkClient#ClientRemoteSignal","content":"Read only &lt;/&gt; networkClient.ClientRemoteSignal: ClientRemoteSignal  "},{"title":"Functions​","type":1,"pageTitle":"networkClient","url":"/libraries/api/networkClient#functions","content":" "},{"title":"allFromParent​","type":1,"pageTitle":"networkClient","url":"/libraries/api/networkClient#allFromParent","content":"&lt;/&gt; networkClient.allFromParent(parent: Instance ) → {[string]: {[string]: any}} Returns an array of all networks dispatched to parent. -- Server local Workspace = game:GetService(&quot;Workspace&quot;) local network1 = network.Server.new(&quot;Test1&quot;, Workspace) network1:append(&quot;status&quot;, &quot;not good mate&quot;) network1:dispatch(Workspace) local network2 = network.Server.new(&quot;Test2&quot;, Workspace) network2:append(&quot;status&quot;, &quot;good mate!&quot;) network2:dispatch(Workspace) -- Client local Workspace = game:GetService(&quot;Workspace&quot;) for _, networkObject in Network.client.fromParent(Workspace) do print(networkObject.status) end --&gt; &quot;not good mate&quot; --&gt; &quot;good mate!&quot;   "},{"title":"fromParent​","type":1,"pageTitle":"networkClient","url":"/libraries/api/networkClient#fromParent","content":"&lt;/&gt; networkClient.fromParent( name: string, parent: Instance , timeout: number? ) → Promise&lt;DispatchedNetwork: {[string]: any}&gt; Returns a promise which is resolved once a network with the name of name, is dispatched to parent. If a network with the name of name is already dispatched to parent, the promise will immediately resolve. For e.g: -- Server local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local Workspace = game:GetService(&quot;Workspace&quot;) local network = require(ReplicatedStorage.Packages.network) local testNetwork = Network.Server.new(&quot;Test&quot;) testNetwork:append(&quot;method&quot;, function(player) return string.format(&quot;hi, %s!&quot;, player.Name) end) -- Dispatch the network to workspace: testNetwork:dispatch(Workspace) -- Client local Workspace = game:GetService(&quot;Workspace&quot;) -- Get the network of name &quot;Test&quot;, dispatched to workspace local testNetwork = network.client.fromParent(&quot;Test&quot;, Workspace):expect() print(testNetwork.method()) --&gt; &quot;hi, bubshurb!&quot; You can also pass in timeout which will result in the promise to be rejected (if it hasn't resolved in time). timeout will default to 20 seconds. "},{"title":"instanceTrackerUtil","type":0,"sectionRef":"#","url":"/libraries/api/instanceTrackerUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"instanceTrackerUtil","url":"/libraries/api/instanceTrackerUtil#functions","content":" "},{"title":"track​","type":1,"pageTitle":"instanceTrackerUtil","url":"/libraries/api/instanceTrackerUtil#track","content":"&lt;/&gt; instanceTrackerUtil.track( instance: Instance , cleanupCallback: ((instance: Instance ) → ())? ) → () Starts tracking the given instance so that the utility can easily cleanup once this instance is untracked. ThecleanupCallback is called instanceTrackerUtil.untrack is called on the instance. instanceTrackerUtil.track(screenGui.Frame, function(frame) frame:TweenPosition(UDim2.fromScale(1, 0)) end)   "},{"title":"bind​","type":1,"pageTitle":"instanceTrackerUtil","url":"/libraries/api/instanceTrackerUtil#bind","content":"&lt;/&gt; instanceTrackerUtil.bind( property: Property.Property, transformer: ( newValue: T, oldValue: T? ) → any ) → () Returns an internal dictionary to be used by instanceTrackerUtil.setProps, the value of property is wrapped onto transformer.  "},{"title":"bindToInstanceProperty​","type":1,"pageTitle":"instanceTrackerUtil","url":"/libraries/api/instanceTrackerUtil#bindToInstanceProperty","content":"&lt;/&gt; instanceTrackerUtil.bindToInstanceProperty( instance: Instance , instanceProperty: string, transformer: ( newValue: T, oldValue: T? ) → any ) → () Returns an internal dictionary to be used by instanceTrackerUtil.setProps, the value of property of instance is wrapped onto transformer. local name = Property.new(&quot;newText&quot;) instanceTrackerUtil.setProps(textLabel, { Text = instanceTrackerUtil.bindToInstanceProperty(Workspace.Baseplate, &quot;Transparency&quot;, function(newTransparency, oldTransparency) return tostring(newTransparency) end) }) Workspace.Baseplate.Transparency = 1 task.defer(function() print(textLabel.Text) --&gt; &quot;1&quot; end)   "},{"title":"bindToInstanceAttribute​","type":1,"pageTitle":"instanceTrackerUtil","url":"/libraries/api/instanceTrackerUtil#bindToInstanceAttribute","content":"&lt;/&gt; instanceTrackerUtil.bindToInstanceAttribute( instance: Instance , attribute: string, transformer: ( newValue: T, oldValue: T? ) → any ) → () Returns an internal dictionary to be used by instanceTrackerUtil.setProps, the attribute (attribute) ofinstanceis wrapped ontotransformer`. local name = Property.new(&quot;newText&quot;) instanceTrackerUtil.setProps(textLabel, { Text = instanceTrackerUtil.bindToInstanceAttribute(Workspace.Baseplate, &quot;SomeAttribute&quot;, function(newAttributeValue, oldAttributeValue) return newAttributeValue end) }) Workspace.Baseplate:SetAttribute(&quot;SomeAttribute&quot;, &quot;TestText&quot;) task.defer(function() print(textLabel.Text) --&gt; &quot;TestText&quot; end)   "},{"title":"setProps​","type":1,"pageTitle":"instanceTrackerUtil","url":"/libraries/api/instanceTrackerUtil#setProps","content":"&lt;/&gt; instanceTrackerUtil.setProps( instance: Instance , props: {[string]: Property.Property | Bind&lt;T&gt;} ) → () Initializes the given instance with props. If properties are specified in props, the instance property will be bind to the *value of the property. Returns a cleanup function which when called, will destroy all properties bound to the instance. local textProp = Property.new(&quot;someText&quot;) local nameProp = Property.new(&quot;test&quot;) instanceTrackerUtil.setProps(textLabel, { Text = textProp, TextStrokeTransparency = 1, -- Bind the &quot;Name&quot; property of the textlabel to a callback -- which will be called every time the &quot;name&quot; property's value -- changes (and is called initially), you can return a new value -- from the callback using the given property value, which'll be -- applied to the instance's property itself. Name = instanceTrackerUtil.bind(nameProp, function(name) return name .. &quot;_Cool&quot; end) }) print(textLabel.Name) --&gt; &quot;test_Cool&quot; nameProp:set(&quot;nope&quot;) print(textLabel.Name) --&gt; &quot;nope_Cool&quot; text:set(&quot;eyes&quot;) print(textLabel.Text) --&gt; &quot;eyes&quot; You can also treat the bound function as a higher order function and return another function from it which will be calledindefinitely until it returns an explicit nil value or the prop reupdates. The function is just passed the latest value of the property and the old value of the property, and it's return value is used as the new value of the property. note The property is updated to the non-nil return value of the function, however it is bulk updated so no on update signals are fired (which effectively prevents the higher order function from being unnecessarily recalled). You can use this to implement cool animations, for e.g a type writer effect: -- Example type writer effect local nameProp = Property.new(&quot;newText&quot;) instanceTrackerUtil.setProps(textLabel, { Name = instanceTrackerUtil.bind(nameProp, function(name) local goalLength = string.len(name) local timeToTake = goalLength / 30 local accumulated = 0 return function(updatedName) -- We are done with the time writer effect, let's return a nil value to stop -- this function from being called. if timeToTake &lt; accumulated then return nil end accumulated += RunService.Heartbeat:Wait() return string.sub(name, 1, math.floor((accumulated / timeToTake) * goalLength)) end end) }) Tweening: local GOAL_TRANSPARENCY = 1 local transparencyProp = Property.new(0) local function lerp(n, g, a) return n + (g - n) * a end local function close(n, g) return (n - g) &lt; 0.001 end instanceTrackerUtil.setProps(Workspace.Baseplate, { Transparency = instanceTrackerUtil.bind(transparencyProp, function() return function(updatedTransparency) if close(updatedTransparency, GOAL_TRANSPARENCY) then return nil end return lerp(updatedTransparency, GOAL_TRANSPARENCY, RunService.Heartbeat:Wait() * 2) end end) })   "},{"title":"untrack​","type":1,"pageTitle":"instanceTrackerUtil","url":"/libraries/api/instanceTrackerUtil#untrack","content":"&lt;/&gt; instanceTrackerUtil.untrack(instance: Instance ) → () Cleans up the given instance and untracks it, if it was previously being tracked. If a cleanup callback for the given instance exists, it will be called. Additionally, all property objects used for the properties of the descendants of the given instance will have their connections cleaned up. local myPart = workspace.MyPart local brickColor = Property.new(BrickColor.Red()) local transparency = Property.new(0) -- Bind the &quot;BrickColor&quot; property of myPart to the above property: instanceTrackerUtil.setProps(myPart, {BrickColor = brickColor}) -- Bind the &quot;Transparency&quot; property of myPart.SomeOtherPart to the above property: instanceTrackerUtil.setProps(myPart.SomeOtherPart, {Transparency = transparency}) -- Track myPart: instanceTrackerUtil.track(myPart, function() -- the transparency and brickColor property will soon have their connections cleaned up, so allow -- them to be set to their default values (myPart's brick color will now turn white -- and myPart.SomeOtherPart's transparency will now be set to 0) brickColor:set(BrickColor.White()) transparency:set(0) end) task.wait(5) instanceTrackerUtil.untrack(myPart)  "},{"title":"numberUnitUtil","type":0,"sectionRef":"#","url":"/libraries/api/numberUnitUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"numberUnitUtil","url":"/libraries/api/numberUnitUtil#functions","content":" "},{"title":"spsToMph​","type":1,"pageTitle":"numberUnitUtil","url":"/libraries/api/numberUnitUtil#spsToMph","content":"&lt;/&gt; numberUnitUtil.spsToMph(sps: number) → number Returns sps (studs per second) converted to mph (miles per second). print(numberUnitUtil.spsToMph(100, 50, 25)) --&gt; 0.75  "},{"title":"playerCharacterUtil","type":0,"sectionRef":"#","url":"/libraries/api/playerCharacterUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"playerCharacterUtil","url":"/libraries/api/playerCharacterUtil#functions","content":" "},{"title":"setCharacterTransparency​","type":1,"pageTitle":"playerCharacterUtil","url":"/libraries/api/playerCharacterUtil#setCharacterTransparency","content":"&lt;/&gt; playerCharacterUtil.setCharacterTransparency( playerCharacter: Model , transparency: number ) → () Set's the transparency of all descendants (Baseparts and decals) in playerCharacter to transparency, except for the primary part.  "},{"title":"distanceFromCharacter​","type":1,"pageTitle":"playerCharacterUtil","url":"/libraries/api/playerCharacterUtil#distanceFromCharacter","content":"&lt;/&gt; playerCharacterUtil.distanceFromCharacter( playerCharacter: Model? , position: Vector3 ) → number Returns the distance from the playerCharacter's primary part to position. If playerCharacter is nil or if the primary part doesn't exist, then this method will return math.huge. "},{"title":"playerCharacterAccessoryUtil","type":0,"sectionRef":"#","url":"/libraries/api/playerCharacterAccessoryUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"playerCharacterAccessoryUtil","url":"/libraries/api/playerCharacterAccessoryUtil#functions","content":" "},{"title":"accessories​","type":1,"pageTitle":"playerCharacterAccessoryUtil","url":"/libraries/api/playerCharacterAccessoryUtil#accessories","content":"&lt;/&gt; playerCharacterAccessoryUtil.accessories( playerCharacter: Model , accessoryType: Enum.AccessoryType ) → {Accessory } Returns an array of all accessories of type accesstoryType in playerCharacter. "},{"title":"orderUtil","type":0,"sectionRef":"#","url":"/libraries/api/orderUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"orderUtil","url":"/libraries/api/orderUtil#functions","content":" "},{"title":"nextOrder​","type":1,"pageTitle":"orderUtil","url":"/libraries/api/orderUtil#nextOrder","content":"&lt;/&gt; orderUtil.nextOrder() → () Returns a function which returns a numerical value, which is always incremented by 1. local nextOrder = orderUtil.nextOrder() print(nextOrder()) --&gt; 1 print(nextOrder()) --&gt; 2 print(nextOrder()) --&gt; 3  "},{"title":"playerCacheUtil","type":0,"sectionRef":"#","url":"/libraries/api/playerCacheUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"playerCacheUtil","url":"/libraries/api/playerCacheUtil#functions","content":" "},{"title":"cleanupPlayerCache​","type":1,"pageTitle":"playerCacheUtil","url":"/libraries/api/playerCacheUtil#cleanupPlayerCache","content":"&lt;/&gt; playerCacheUtil.cleanupPlayerCache(player: Player ) → () Cleans up the given player's cache. Calls to playerCacheUtil.cacheForPlayer for the same player will now return a global empty table. -- Script 1: local cache = playerCacheUtil.cleanupPlayerCache(player) cache.test = 150 print(cache) --&gt; {test = 150} print(playerCacheUtil.cacheForPlayer(player) == cache) --&gt; true playerCacheUtil.cleanupPlayerCache(player) local cacheNow = playerCacheUtil.cacheForPlayer(player) print(cacheNow) --&gt; {} print(cacheNow == cache) --&gt; false Potential memory leak This method assigns an attribute to the player object, __playerCacheCleanup for cleanup purposes. If this attribute is removed as a result of developer work, then this can potentially induce a memory leak! Ideally you should call this method for the player once they leave the game.  "},{"title":"cacheForPlayer​","type":1,"pageTitle":"playerCacheUtil","url":"/libraries/api/playerCacheUtil#cacheForPlayer","content":"&lt;/&gt; playerCacheUtil.cacheForPlayer(player: Player ) → () Returns the cache for the given player. Uniqueness Player caches are stored per each player, uniquely keyed by script names. This means a player's cache will always be unique when accessed from different scripts. For e.g: -- Script 1: local cache = playerCacheUtil.cacheForPlayer(player) cache.test = 1 print(cache) --&gt; {test = 1} -- Script 2: local cache = playerCacheUtil.cacheForPlayer(player) cache.opper = 5 print(cache) --&gt; {opper = 5}  "},{"title":"playerPolicyInfoUtil","type":0,"sectionRef":"#","url":"/libraries/api/playerPolicyInfoUtil","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"playerPolicyInfoUtil","url":"/libraries/api/playerPolicyInfoUtil#types","content":" "},{"title":"PlayerPolicyInfo​","type":1,"pageTitle":"playerPolicyInfoUtil","url":"/libraries/api/playerPolicyInfoUtil#PlayerPolicyInfo","content":"&lt;/&gt; interface PlayerPolicyInfo { ArePaidRandomItemsRestricted: boolean AllowedExternalLinkReferences: {string} IsPaidItemTradingAllowed: boolean IsSubjectToChinaPolicies: boolean }   "},{"title":"DefaultPlayerPolicyInfo​","type":1,"pageTitle":"playerPolicyInfoUtil","url":"/libraries/api/playerPolicyInfoUtil#DefaultPlayerPolicyInfo","content":"&lt;/&gt; interface DefaultPlayerPolicyInfo { ArePaidRandomItemsRestricted: false AllowedExternalLinkReferences: {} IsPaidItemTradingAllowed: false IsSubjectToChinaPolicies: false }  "},{"title":"Functions​","type":1,"pageTitle":"playerPolicyInfoUtil","url":"/libraries/api/playerPolicyInfoUtil#functions","content":" "},{"title":"playerPolicyInfo​","type":1,"pageTitle":"playerPolicyInfoUtil","url":"/libraries/api/playerPolicyInfoUtil#playerPolicyInfo","content":"&lt;/&gt; playerPolicyInfoUtil.playerPolicyInfo(player: Player ) → Promise&lt;PlayerPolicyInfo&gt; Returns a promise which is resolved with the policy info of player, if successfully retrieved. If the policy info of the given player couldn't be retrieved, then the promise will reject with DefaultPlayerPolicyInfo and the error message. playerPolicyInfoUtil.playerPolicyInfo(somePlayer):andThen(function(policyInfo) print(policyInfo.ArePaidRandomItemsRestricted) end):catch(function(defaultPolicyInfo, errorMessage) warn(tostring(errorMessage)) end) Read only policy info The policy info table will be read-only, through table.freeze. "},{"title":"playerEventsUtil","type":0,"sectionRef":"#","url":"/libraries/api/playerEventsUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"playerEventsUtil","url":"/libraries/api/playerEventsUtil#functions","content":" "},{"title":"usePlayerAdded​","type":1,"pageTitle":"playerEventsUtil","url":"/libraries/api/playerEventsUtil#usePlayerAdded","content":"&lt;/&gt; playerEventsUtil.usePlayerAdded(callback: (player: Player ) → ()) → () A simple wrapper for the PlayerAdded event. This method additionally captures current players in game; during the time of the execution of this method, as well. playerUtil.usePlayerAdded(function(player) print(player.Name, &quot; joined the game!&quot;) end)   "},{"title":"usePlayerCharacterAdded​","type":1,"pageTitle":"playerEventsUtil","url":"/libraries/api/playerEventsUtil#usePlayerCharacterAdded","content":"&lt;/&gt; playerEventsUtil.usePlayerCharacterAdded( player: Player , callback: ( newPlayerCharacter: Model , oldPlayerCharacter: Model? ) → () ) → () A wrapper over the player.CharacterAdded event. Also runs the given callback initially if player.Character is a truthy value, passing in newCharacter (while oldCharacter = nil). playerEventsUtil.usePlayerCharacterAdded(player, function(newCharacter, oldCharacter) end)  "},{"title":"instanceUtil","type":0,"sectionRef":"#","url":"/libraries/api/instanceUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"instanceUtil","url":"/libraries/api/instanceUtil#functions","content":" "},{"title":"setInstanceProperties​","type":1,"pageTitle":"instanceUtil","url":"/libraries/api/instanceUtil#setInstanceProperties","content":"&lt;/&gt; instanceUtil.setInstanceProperties( instance: Instance , properties: {[string]: any}, tweenInfo: TweenInfo? ) → () Sets the properties of instance from the properties table. instanceUtil.setInstanceProperties(workspace.Baseplate, {Transparency = 1}) print(workspace.Baseplate.Transparency) --&gt; 1 local tween = instanceUtil.setInstanceProperties(workspace.Baseplate, {Transparency = 0}, TweenInfo.new(5)) tween.Completed:Wait()   "},{"title":"observeProperty​","type":1,"pageTitle":"instanceUtil","url":"/libraries/api/instanceUtil#observeProperty","content":"&lt;/&gt; instanceUtil.observeProperty( instance: Instance , property: string, observer: ( newValue: any, oldValue: any ) → () ) → () Observes the given property of the instance. observer will be called initially, being passed the current value of the property. As the property updates, observer will be called being passed both the new value of the property and the old value. Returns a RBXScriptConnection which upon being disconnected; will allow code to know not to observe the property anymore. instanceUtil.observeProperty(workspace.Baseplate, &quot;Anchored&quot;, function(newPropertyValue, oldPropertyValue) print(newPropertyValue, oldPropertyValue) end)   "},{"title":"setInstanceAttributes​","type":1,"pageTitle":"instanceUtil","url":"/libraries/api/instanceUtil#setInstanceAttributes","content":"&lt;/&gt; instanceUtil.setInstanceAttributes( instance: Instance , attributes: {[string]: any} ) → () Sets the attributes of instance from the attributes table. instanceUtil.setInstanceAttributes(workspace.Baseplate, {IsMayoSauce = true}) print(workspace.Baseplate:GetAttribute(&quot;IsMayoSauce&quot;)) --&gt; true   "},{"title":"addTagsToInstance​","type":1,"pageTitle":"instanceUtil","url":"/libraries/api/instanceUtil#addTagsToInstance","content":"&lt;/&gt; instanceUtil.addTagsToInstance( instance: Instance , tags: {string} ) → () Adds all tags to `instance. instanceUtil.addTagsToInstance(workspace.Baseplate, {&quot;IsMayoSauce&quot;}) print(workspace.Baseplate:HasTag(&quot;IsMayoSauce&quot;)) --&gt; true   "},{"title":"addTagsToInstance​","type":1,"pageTitle":"instanceUtil","url":"/libraries/api/instanceUtil#addTagsToInstance","content":"&lt;/&gt; instanceUtil.addTagsToInstance( instance: Instance , tags: {string} ) → () Adds all tags in tags to the given instance as CollectionService tags. instanceUtil.addTagsToInstance(workspace.Baseplate, {&quot;Test&quot;}) print(CollectionService:HasTag(workspace.Baseplate, &quot;Test&quot;)) --&gt; true   "},{"title":"removeTagsFromInstance​","type":1,"pageTitle":"instanceUtil","url":"/libraries/api/instanceUtil#removeTagsFromInstance","content":"&lt;/&gt; instanceUtil.removeTagsFromInstance( instance: Instance , tags: {string} ) → () Removes all tags in tags (which were tagged to the given instance as CollectionService tags) from the given instance. instanceUtil.addTagsToInstance(workspace.Baseplate, {&quot;Test&quot;}) print(CollectionService:HasTag(workspace.Baseplate, &quot;Test&quot;)) --&gt; true instanceUtil.removeTagsFromInstance(workspace.Baseplate, {&quot;Test&quot;}) print(CollectionService:HasTag(workspace.Baseplate, &quot;Test&quot;)) --&gt; false   "},{"title":"setInstancePhysicsCollisionGroup​","type":1,"pageTitle":"instanceUtil","url":"/libraries/api/instanceUtil#setInstancePhysicsCollisionGroup","content":"&lt;/&gt; instanceUtil.setInstancePhysicsCollisionGroup( instance: Instance , collisionGroup: string ) → () Sets the collision group of instance to collisionGroup, if it is a BasePart. Else, all the descendants of instance (BaseParts only) will have their collision group set to collisionGroup. local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local PhysicsService = game:GetService(&quot;PhysicsService&quot;) local Workspace = game:GetService(&quot;Workspace&quot;) PhysicsService:CreateCollisionGroup(&quot;Test&quot;) instanceUtil.setInstancePhysicsCollisionGroup(Workspace.Baseplate, &quot;Test&quot;) instanceUtil.setInstancePhysicsCollisionGroup(Workspace.SomeModel, &quot;Test&quot;)   "},{"title":"resetInstancePhysicsCollisionGroup​","type":1,"pageTitle":"instanceUtil","url":"/libraries/api/instanceUtil#resetInstancePhysicsCollisionGroup","content":"&lt;/&gt; instanceUtil.resetInstancePhysicsCollisionGroup(instance: Instance ) → () Sets the collision group of instance to Default, if it is a BasePart. Else, all the descendants of instance (BaseParts only) will have their collision group set to &quot;Default&quot;. local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local PhysicsService = game:GetService(&quot;PhysicsService&quot;) local Workspace = game:GetService(&quot;Workspace&quot;) PhysicsService:CreateCollisionGroup(&quot;Test&quot;) instanceUtil.setInstancePhysicsCollisionGroup(Workspace.Baseplate, &quot;Test&quot;) instanceUtil.setInstancePhysicsCollisionGroup(Workspace.SomeModel, &quot;Test&quot;) -- Okay on second thought, let's actually remove the collision group from these -- instances: instanceUtil.resetInstancePhysicsCollisionGroup(Workspace.Baseplate) instanceUtil.resetInstancePhysicsCollisionGroup(Workspace.SomeModel)   "},{"title":"setInstancePhysicalProperties​","type":1,"pageTitle":"instanceUtil","url":"/libraries/api/instanceUtil#setInstancePhysicalProperties","content":"&lt;/&gt; instanceUtil.setInstancePhysicalProperties( instance: Instance , physicalProperties: PhysicalProperties ) → () Sets the PhysicalProperties of instance to physicalProperties, if it is a BasePart. Else, all the descendants of instance (BaseParts only) will have their physical properties set to physicalProperties. local Workspace = game:GetService(&quot;Workspace&quot;) instanceUtil.setInstancePhysicalProperties(Workspace.Baseplate, PhysicalProperties.new(5, 2, 3)) print(Workspace.Baseplate.Density) --&gt; 5 print(Workspace.Baseplate.Elasticity) --&gt; 2 print(Workspace.Baseplate.ElasticityWeight) --&gt; 3   "},{"title":"resetInstancePhysicalProperties​","type":1,"pageTitle":"instanceUtil","url":"/libraries/api/instanceUtil#resetInstancePhysicalProperties","content":"&lt;/&gt; instanceUtil.resetInstancePhysicalProperties(instance: Instance ) → () Sets the PhysicalProperties of instance to the default, if it is a BasePart. Else, all the descendants of instance (BaseParts only) will have their physical properties set to the default. local Workspace = game:GetService(&quot;Workspace&quot;) instanceUtil.setInstancePhysicalProperties(Workspace.Baseplate, PhysicalProperties.new(5, 2, 3)) print(Workspace.Baseplate.Density) --&gt; 5 print(Workspace.Baseplate.Elasticity) --&gt; 2 print(Workspace.Baseplate.ElasticityWeight) --&gt; 3 -- Okay on second thought, let's remove the physical properties -- we've set on the instance: instanceUtil.resetInstancePhysicalProperties(Workspace.Baseplate) print(Workspace.Baseplate.Density) --&gt; 0.7 print(Workspace.Baseplate.Elasticity) --&gt; 0.5 print(Workspace.Baseplate.ElasticityWeight) --&gt; 1   "},{"title":"instanceCorners​","type":1,"pageTitle":"instanceUtil","url":"/libraries/api/instanceUtil#instanceCorners","content":"&lt;/&gt; instanceUtil.instanceCorners(instance: BasePart ) → { top: {Vector3 }, bottom: {Vector3 } } Returns a read-only dictionary of all corners of instance, top and bottom.  "},{"title":"instanceFloorMaterial​","type":1,"pageTitle":"instanceUtil","url":"/libraries/api/instanceUtil#instanceFloorMaterial","content":"&lt;/&gt; instanceUtil.instanceFloorMaterial( instance: BasePart , raycastParams: RaycastParams?, depth: number? ) → Enum.Material Returns the material the instance is lying on. If instance is underwater, then Enum.Material.Water will be returned, elseif instance is in air, then Enum.Material.Air will be returned. The 2nd argument can be passed as a RaycastParams object, which will be used in determining the material of instance through ray casting. The 3rd argument can be passed as a number (depth) which will increase the length of the ray by depth studs (on the Y-axis). This is only useful when you want to add in more leeway in determining the material of instance reliably, since sometimes the instance may be very slightly over the top of some ground due to its geometry so in those cases, the ray may not register properly. If this argument isn't specified, then it will default to 0.01.   "},{"title":"safeSetInstanceNetworkOwner​","type":1,"pageTitle":"instanceUtil","url":"/libraries/api/instanceUtil#safeSetInstanceNetworkOwner","content":"&lt;/&gt; instanceUtil.safeSetInstanceNetworkOwner( instance: BasePart , networkOwner: Player? ) → () Sets the network owner of instance to networkOwner safely. Safe to call This method should be preferred over directly setting the network owner of instance via SetNetworkOwner, as it won't error in cases where the network ownership API cannot be used on instance.  "},{"title":"safeInstanceNetworkOwner​","type":1,"pageTitle":"instanceUtil","url":"/libraries/api/instanceUtil#safeInstanceNetworkOwner","content":"&lt;/&gt; instanceUtil.safeInstanceNetworkOwner(instance: BasePart ) → Player?  Returns the network owner of instance safely. Safe to call This method should be preferred over directly getting the network owner of instance via GetNetworkOwner, as it will safely return nil (instead of erroring) in cases where the network ownership API cannot be used on instance! "},{"title":"playerRefUtil","type":0,"sectionRef":"#","url":"/libraries/api/playerRefUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"playerRefUtil","url":"/libraries/api/playerRefUtil#functions","content":" "},{"title":"playerRefPromise​","type":1,"pageTitle":"playerRefUtil","url":"/libraries/api/playerRefUtil#playerRefPromise","content":"&lt;/&gt; playerRefUtil.playerRefPromise(playerUserId: number) → () Promisified version of playerRefUtil.playerRef.  "},{"title":"playerRef​","type":1,"pageTitle":"playerRefUtil","url":"/libraries/api/playerRefUtil#playerRef","content":"&lt;/&gt; playerRefUtil.playerRef(playerUserId: number) → Player?  Returns the player ref from playerUserId. "},{"title":"positionUtil","type":0,"sectionRef":"#","url":"/libraries/api/positionUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"positionUtil","url":"/libraries/api/positionUtil#functions","content":" "},{"title":"randomPosition​","type":1,"pageTitle":"positionUtil","url":"/libraries/api/positionUtil#randomPosition","content":"&lt;/&gt; positionUtil.randomPosition( position: Vector3 , size: Vector3 , specifiedRandom: Random? ) → () Returns a random position from the given position and the size. A third argument (specifiedRandom) can be passed which will be used in calculating the random position. "},{"title":"playerHumanoidUtil","type":0,"sectionRef":"#","url":"/libraries/api/playerHumanoidUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"playerHumanoidUtil","url":"/libraries/api/playerHumanoidUtil#functions","content":" "},{"title":"playerHumanoid​","type":1,"pageTitle":"playerHumanoidUtil","url":"/libraries/api/playerHumanoidUtil#playerHumanoid","content":"&lt;/&gt; playerHumanoidUtil.playerHumanoid(player: Player ) → Humanoid?  Attempts to return the given player's character's humanoid, if found.  "},{"title":"playerHumanoidPromise​","type":1,"pageTitle":"playerHumanoidUtil","url":"/libraries/api/playerHumanoidUtil#playerHumanoidPromise","content":"&lt;/&gt; playerHumanoidUtil.playerHumanoidPromise(player: Player ) → Promise&lt;Humanoid &gt; Promisfied verison of playerHumanoidUtil.playerHumanoid.  "},{"title":"seatPlayer​","type":1,"pageTitle":"playerHumanoidUtil","url":"/libraries/api/playerHumanoidUtil#seatPlayer","content":"&lt;/&gt; playerHumanoidUtil.seatPlayer( player: Player , seat: VehicleSeat | Seat ) → () Attempts the seat the given player in seat if seat.Occupant = nil. Handles an edgecase where seat:Sit does not work if given humanoid was seated, by unsitting the humanoid through humanoid.Sit = false and then seating the humanoid.  "},{"title":"playerHumanoidSeatPartObserver​","type":1,"pageTitle":"playerHumanoidUtil","url":"/libraries/api/playerHumanoidUtil#playerHumanoidSeatPartObserver","content":"&lt;/&gt; playerHumanoidUtil.playerHumanoidSeatPartObserver( player: Player , observerSeated: (( newSeatPlayerIsSittingOn: Seat | VehicleSeat , oldSeatPlayerWasSittingOn: (Seat | VehicleSeat )? ) → ())?, observerUnseated: (( newSeatPlayerIsNoLongerSittingOn: (Seat | VehicleSeat )?, oldSeatPlayerWasNoLongerSittingOn: (Seat | VehicleSeat )? ) → ())? ) → () → () playerHumanoidUtil.playerHumanoidSeatPartObserver(player, function(newSeatPlayerIsSittingOn) print(player.Name .. &quot; sat on seat &quot; ..tostring(newSeatPlayerIsSittingOn.Name)) end, function(newSeatPlayerIsNoLongerSittingOn) if newSeatPlayerIsNoLongerSittingOn ~= nil then print(player.Name .. &quot; left seat &quot; ..tostring(newSeatPlayerIsNoLongerSittingOn.Name)) end end) While you can simply listen to humanoid.SeatPart, this method accounts for new player character reloading. Returns a cleanup function. "},{"title":"playersUtil","type":0,"sectionRef":"#","url":"/libraries/api/playersUtil","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"playersUtil","url":"/libraries/api/playersUtil#properties","content":" "},{"title":"defaultUserThumbnail​","type":1,"pageTitle":"playersUtil","url":"/libraries/api/playersUtil#defaultUserThumbnail","content":"&lt;/&gt; playersUtil.defaultUserThumbnail: &quot;rbxassetid://0&quot;  "},{"title":"Functions​","type":1,"pageTitle":"playersUtil","url":"/libraries/api/playersUtil#functions","content":" "},{"title":"playerThumbnailPromise​","type":1,"pageTitle":"playersUtil","url":"/libraries/api/playersUtil#playerThumbnailPromise","content":"&lt;/&gt; playersUtil.playerThumbnailPromise( userId: number, thumbnailType: Enum.ThumbnailType, thumbnailSize: Enum.ThumbnailSize, retryTimes: number? ) → () Returns a promise which is based off of Promise.retry, wrapped over Players:GetUserThumbnailAsync. The returned promise will retry upto retryTimes (or 3 times, if retryTimes is not specified).  "},{"title":"playerFromInstance​","type":1,"pageTitle":"playersUtil","url":"/libraries/api/playersUtil#playerFromInstance","content":"&lt;/&gt; playersUtil.playerFromInstance(instance: Instance ) → Player?  Returns a player from the given instance, if found. This is an efficient wrapper over Players:GetPlayerFromCharacter. laser.Touched:Connect(function(hit) local player = playerUtil.playerFromInstance(hit) if player then -- Damage the player end end)   "},{"title":"nameFromUserId​","type":1,"pageTitle":"playersUtil","url":"/libraries/api/playersUtil#nameFromUserId","content":"&lt;/&gt; playersUtil.nameFromUserId(userId: number) → Promise&lt;string&gt; Returns a promise which is resolved with the user name associated to the user id. Caching behavior This method will immediately cache in the name (retrieved from the given user id), so calls for the same user id will return in cached user name immediately. playersUtil.nameFromUserId(2981707497):andThen(function(userName) print(userName) --&gt; &quot;bubshurb&quot; end)   "},{"title":"userIdFromName​","type":1,"pageTitle":"playersUtil","url":"/libraries/api/playersUtil#userIdFromName","content":"&lt;/&gt; playersUtil.userIdFromName(userName: string) → Promise&lt;number&gt; Returns a promise which is resolved with the user id associated to the username. Caching behavior This method will immediately cache in the user id (retrieved from the given username), so calls for the same username will return in cached user id immediately. playersUtil.userIdFromName(&quot;bubshurb&quot;):andThen(function(userId) print(userId) --&gt; 2981707497 end)  "},{"title":"queryUtil","type":0,"sectionRef":"#","url":"/libraries/api/queryUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"queryUtil","url":"/libraries/api/queryUtil#functions","content":" "},{"title":"query​","type":1,"pageTitle":"queryUtil","url":"/libraries/api/queryUtil#query","content":"&lt;/&gt; queryUtil.query( queryResults: {T}, queryAddition: RBXScriptSignal , queryRemoving: RBXScriptSignal ) → ( {T}, () → () ) Returns a cleanup callback which disconnects the queryAddition and queryRemoving signals. local Workspace = game:GetService(&quot;Workspace&quot;) local queryResults, cleanup = queryUtil.query(Workspace:GetDescendants(), Workspace.DescendantAdded, Workspace.DescendantRemoving)  "},{"title":"propertyUtil","type":0,"sectionRef":"#","url":"/libraries/api/propertyUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"propertyUtil","url":"/libraries/api/propertyUtil#functions","content":" "},{"title":"increment​","type":1,"pageTitle":"propertyUtil","url":"/libraries/api/propertyUtil#increment","content":"&lt;/&gt; propertyUtil.increment(property: Property.Property&lt;number&gt;) → () Increments the given property's value by 1.  "},{"title":"decrement​","type":1,"pageTitle":"propertyUtil","url":"/libraries/api/propertyUtil#decrement","content":"&lt;/&gt; propertyUtil.decrement(property: Property.Property&lt;number&gt;) → () Decrements the given property's value by 1 though clamping the property's value such that it does not become less than 0. "},{"title":"rbxScriptSignalUtil","type":0,"sectionRef":"#","url":"/libraries/api/rbxScriptSignalUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"rbxScriptSignalUtil","url":"/libraries/api/rbxScriptSignalUtil#functions","content":" "},{"title":"initEvents​","type":1,"pageTitle":"rbxScriptSignalUtil","url":"/libraries/api/rbxScriptSignalUtil#initEvents","content":"&lt;/&gt; rbxScriptSignalUtil.initEvents(events: {[RBXScriptSignal ]: (...any) → ()}) → () Initializes events. Returns a cleanup function which upon being called, will cleanup all the events. rbxScriptSignalUtil.initEvents({ [workspace.ChildAdded] = function(child) print(child.Name, &quot;added to Workspace!&quot;) end })  "},{"title":"robuxConversionUtil","type":0,"sectionRef":"#","url":"/libraries/api/robuxConversionUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"robuxConversionUtil","url":"/libraries/api/robuxConversionUtil#functions","content":" "},{"title":"robuxToDollar​","type":1,"pageTitle":"robuxConversionUtil","url":"/libraries/api/robuxConversionUtil#robuxToDollar","content":"&lt;/&gt; robuxConversionUtil.robuxToDollar(robux: number) → () Returns the given robux converted to dollars.  "},{"title":"dollarToRobux​","type":1,"pageTitle":"robuxConversionUtil","url":"/libraries/api/robuxConversionUtil#dollarToRobux","content":"&lt;/&gt; robuxConversionUtil.dollarToRobux(dollar: number) → () Returns the given dollar converted to robux. "},{"title":"playerUtil","type":0,"sectionRef":"#","url":"/libraries/api/playerUtil","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"playerUtil","url":"/libraries/api/playerUtil#types","content":" "},{"title":"playerSafeChatStatus​","type":1,"pageTitle":"playerUtil","url":"/libraries/api/playerUtil#playerSafeChatStatus","content":"&lt;/&gt; interface playerSafeChatStatus { On: &quot;On&quot; Off: &quot;Off&quot; Unknown: &quot;Unknown&quot; }  "},{"title":"Properties​","type":1,"pageTitle":"playerUtil","url":"/libraries/api/playerUtil#properties","content":" "},{"title":"defaultPlayerGroupRank​","type":1,"pageTitle":"playerUtil","url":"/libraries/api/playerUtil#defaultPlayerGroupRank","content":"&lt;/&gt; playerUtil.defaultPlayerGroupRank: 0   "},{"title":"defaultPlayerGroupRole​","type":1,"pageTitle":"playerUtil","url":"/libraries/api/playerUtil#defaultPlayerGroupRole","content":"&lt;/&gt; playerUtil.defaultPlayerGroupRole: &quot;Guest&quot;  "},{"title":"Functions​","type":1,"pageTitle":"playerUtil","url":"/libraries/api/playerUtil#functions","content":" "},{"title":"playerGroupRank​","type":1,"pageTitle":"playerUtil","url":"/libraries/api/playerUtil#playerGroupRank","content":"&lt;/&gt; playerUtil.playerGroupRank( playerUserId: number, groupId: number ) → Promise&lt;groupId: number&gt; Returns a promise which is resolved with the group rank of the player in the given group. If the group rank couldn't be retrieved, then the promise will reject with [DefaultGroupRank] and with the error message. playerUtil.playerGroupRank(2981707497, 1):andThen(function(groupRank) print(groupRank) end):catch(function(defaultGroupRank, errorMessage) print(groupRank, tostring(errorMessage)) end)   "},{"title":"playerIsFriendsWith​","type":1,"pageTitle":"playerUtil","url":"/libraries/api/playerUtil#playerIsFriendsWith","content":"&lt;/&gt; playerUtil.playerIsFriendsWith( player: Player , userId: number ) → Promise&lt;boolean&gt; Returns a promise which is resolved with a boolean indicating whether or not the given player is friends with the given userId. This is a wrapper over Player:IsFriendsWith. playerUtil.playerIsFriendsWith(2981707497, 27842645):andThen(function(isFriends) print(isFriends) end):catch(function(isFriends, errorMessage) print(isFriends, tostring(errorMessage)) end)   "},{"title":"playerFriendsOnline​","type":1,"pageTitle":"playerUtil","url":"/libraries/api/playerUtil#playerFriendsOnline","content":"&lt;/&gt; playerUtil.playerFriendsOnline( player: Player , maxFriends: number ) → Promise&lt;{...}&gt; Returns a promise which is resolved with an array of fields of info regarding the given player's friends. This is a wrapper over Player:GetFriendsOnline. playerUtil.playerFriendsOnline(player, 15):andThen(function(friends) for _, friend in friends do print(friend.UserName) end end):catch(function(friends, errorMessage) -- friends will be an empty array print(friends, tostring(errorMessage)) end)   "},{"title":"playerGroupRole​","type":1,"pageTitle":"playerUtil","url":"/libraries/api/playerUtil#playerGroupRole","content":"&lt;/&gt; playerUtil.playerGroupRole( playerUserId: number, groupId: number ) → Promise&lt;groupRole: string&gt; Returns a promise which is resolved with the group role of the player in the given group. If the group role couldn't be retrieved, then the promise will reject with [DefaultGroupRole] and with the error message. playerUtil.playerGroupRole(2981707497, 1):andThen(function(groupRole) print(groupRole) end):catch(function(defaultGroupRole, errorMessage) warn(tostring(errorMessage)) end)   "},{"title":"playerIsInGroup​","type":1,"pageTitle":"playerUtil","url":"/libraries/api/playerUtil#playerIsInGroup","content":"&lt;/&gt; playerUtil.playerIsInGroup( playerUserId: number, groupId: number ) → Promise&lt;boolean&gt; Returns a promise which is resolved with a boolean indicating if the given player is in the given group or not. If the player's group status couldn't be retrieved, then the promise will reject with a false value, along with the error message. playerUtil.playerIsInGroup(2981707497, 1):andThen(function(playerIsInGroup) print(playerIsInGroup) end):catch(function(playerIsInGroup, errorMessage) -- playerIsInGroup will always be false here print(playerIsInGroup, tostring(errorMessage)) end)   "},{"title":"loadCharacterQueued​","type":1,"pageTitle":"playerUtil","url":"/libraries/api/playerUtil#loadCharacterQueued","content":"&lt;/&gt; playerUtil.loadCharacterQueued(player: Player ) → Promise&lt;Model &gt; A simple wrapper over Player:LoadCharacter, except that it handles the necessary edge cases to ensure smooth player character loading. Player character loading queue Player character loadings are queued; so if you call this method for a player while it was previously called for the same player (and that operation has not yet completed), then the new call will not load the player's character until the previous player character load call has finished. playerUtil.loadCharacterQueued(player) playerUtil.loadCharacterQueued(player) -- This operation won't load the character until the above call finishes loading the character. playerUtil.loadCharacterQueued(player):andThen(function(newPlayerCharacter) print(newPlayerCharacter) end):catch(function(errorMessage) print(tostring(errorMessage)) end)   "},{"title":"safeChatStatus​","type":1,"pageTitle":"playerUtil","url":"/libraries/api/playerUtil#safeChatStatus","content":"&lt;/&gt; playerUtil.safeChatStatus(player: Player ) → Promise&lt;&quot;On&quot; | &quot;Off&quot; | &quot;Unknown&quot;&gt; Returns a promise which is resolved with the safe chat status of the given player. playerUtil.safeChatStatus(player):andThen(function(safeChatStatus) print(safeChatStatus == playerUtil.playerSafeChatStatus.on) end)  "},{"title":"seatUtil","type":0,"sectionRef":"#","url":"/libraries/api/seatUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"seatUtil","url":"/libraries/api/seatUtil#functions","content":" "},{"title":"seatOccupanciesProperty​","type":1,"pageTitle":"seatUtil","url":"/libraries/api/seatUtil#seatOccupanciesProperty","content":"&lt;/&gt; seatUtil.seatOccupanciesProperty(seats: {Seat | VehicleSeat }) → Property&lt;{Seat | VehicleSeat }: Player &gt; Returns a property which is updated based on the Occupant property of the given seats. Also returns a trove object which will cleanup everything. "},{"title":"schedulerUtil","type":0,"sectionRef":"#","url":"/libraries/api/schedulerUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"schedulerUtil","url":"/libraries/api/schedulerUtil#functions","content":" "},{"title":"schedule​","type":1,"pageTitle":"schedulerUtil","url":"/libraries/api/schedulerUtil#schedule","content":"&lt;/&gt; schedulerUtil.schedule( runServiceEventName: string, callbackIdentifier: string, callback: (...any) → () ) → () → () Schedules the given callback to be run during the given run service event. This is useful because this utility sets up all these events once and registers the given callbacks to be called during each event's invocation point - this prevents you from initializing many different types of RunService events. schedulerUtil.schedule(schedulerUtil.RunServiceEvent.Heartbeat, &quot;PerformMaths&quot; function(deltaTime: number) local sum = 2 + 2 * deltaTime end) Additionally, this method also returns a cleanup function which upon being called, will call schedulerUtil.unschedule for the given scheduler. Yielding is not allowed Scheduler callbacks can never yield. If they do so, an error will be outputted in the console. Yielding in code that needs to run potentially every frame can result in weird bugs. Automatic performance profiling A profile is created for every scheduler callback using debug.profilebegin(callbackIdentifier), which will allow you to easily monitor the performance of individual scheduler callbacks. Additionally, an warn is outputted in the console every 10 seconds whenever a scheduled callback takes longer than 0.4seconds to run.  "},{"title":"unschedule​","type":1,"pageTitle":"schedulerUtil","url":"/libraries/api/schedulerUtil#unschedule","content":"&lt;/&gt; schedulerUtil.unschedule( runServiceEventName: string, callbackIdentifier: string ) → () Deschedules the given RunService event bound callback. "},{"title":"Property","type":0,"sectionRef":"#","url":"/libraries/api/Property","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Property","url":"/libraries/api/Property#types","content":" "},{"title":"Property​","type":1,"pageTitle":"Property","url":"/libraries/api/Property#Property","content":"&lt;/&gt; type Property = Property&lt;T&gt;  "},{"title":"Properties​","type":1,"pageTitle":"Property","url":"/libraries/api/Property#properties","content":" "},{"title":"onUpdate​","type":1,"pageTitle":"Property","url":"/libraries/api/Property#onUpdate","content":"This item is read only and cannot be modified. Read Only Signal Property Instance &lt;/&gt; Property.onUpdate: Signal&lt;newValue: any,oldValue: any&gt; A signal which is fired whenever the value of the property is set to a new one. The signal is only passed the new value as the only argument. "},{"title":"Functions​","type":1,"pageTitle":"Property","url":"/libraries/api/Property#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Property","url":"/libraries/api/Property#new","content":"&lt;/&gt; Property.new(initialValue: T?) → Property A constructor method that creates a new property object, with initialValue as the current value of the property.  "},{"title":"is​","type":1,"pageTitle":"Property","url":"/libraries/api/Property#is","content":"&lt;/&gt; Property.is(self: any) → boolean A method that returns a boolean indicating if self is a property or not.  "},{"title":"clone​","type":1,"pageTitle":"Property","url":"/libraries/api/Property#clone","content":"&lt;/&gt; Property:clone(mapper: (( newValue: any, oldValue: any ) → any)?) → () Creates a new property and binds it to the current property, and returns the new property. The new property will operate on the value of the current property, however you may specify a mapper function for more control. The mapper function will be passed the new value and the old value of the current property (and when the current property is updated), the return value of the mapper will be the new value of the new property. The new property will be automatically destroyed once the current prpoerty is destroyed. local property = Property.new(5) local anotherProperty = property:clone(function(number) return number + 5 end) print(anotherProperty:get()) --&gt; 10 property:set(10) print(anotherProperty:get()) --&gt; 15   "},{"title":"bindToInstanceProperty​","type":1,"pageTitle":"Property","url":"/libraries/api/Property#bindToInstanceProperty","content":"&lt;/&gt; Property:bindToInstanceProperty( instance: Instance , property: string ) → () Binds the property to a property of the given Roblox instance. When the instance is destroyed, the property is automatically destroyed as well. local property = Property.new() property:bindToInstanceProperty(workspace.Baseplate, &quot;Transparency&quot;) property.onUpdate:Connect(function(newTransparency, oldTransparency) print(newTransparency, oldTransparency) --&gt; 1, 0 end) print(property:get()) --&gt; 0 workspace.Baseplate.Transparency = 1 -- Deferred signal behavior: (Roblox instance-signals are not immediately fired) print(property.onUpdate:Wait()) --&gt; 1   "},{"title":"bindToInstanceAttribute​","type":1,"pageTitle":"Property","url":"/libraries/api/Property#bindToInstanceAttribute","content":"&lt;/&gt; Property:bindToInstanceAttribute( instance: Instance , attribute: string ) → () Binds the property to an attribute of the given Roblox instance. When the instance is destroyed, the property is automatically destroyed as well. local property = Property.new() property:bindToInstanceAttribute(workspace.Baseplate, &quot;SomeAttribute&quot;) print(property:get()) --&gt; nil workspace.Baseplate:SetAttribute(&quot;SomeAttribute&quot;, 5) print(property:get()) --&gt; 5   "},{"title":"bindToInstance​","type":1,"pageTitle":"Property","url":"/libraries/api/Property#bindToInstance","content":"&lt;/&gt; Property:bindToInstance(instance: Instance ) → () Binds the property to an instance so that once the instance is destroyed, the property will be destroyed too. local property = Property.new() property:bindToInstance(workspace.Baseplate) print(Property.is(property)) --&gt; true workspace.Baseplate:Destroy() task.wait() -- Deferred signal behavior print(Property.is(property)) --&gt; false   "},{"title":"set​","type":1,"pageTitle":"Property","url":"/libraries/api/Property#set","content":"&lt;/&gt; Property:set(value: any) → () Sets the value of the property to value, if this new value isn't the same as the previous value.  "},{"title":"observe​","type":1,"pageTitle":"Property","url":"/libraries/api/Property#observe","content":"&lt;/&gt; Property:observe(callback: ( newValue: any, oldValue: any ) → ()) → () Observes the value of the property. property:observe(function(newValue, oldValue) end)   "},{"title":"valuePromise​","type":1,"pageTitle":"Property","url":"/libraries/api/Property#valuePromise","content":"&lt;/&gt; Property:valuePromise(valuePredicate: (( newValue: any, oldValue: any ) → boolean)?) → Promise Returns a promise which is resolved with a non-nil value of the property, given thatvaluePredicate is not passed as an argument. local property = Property.new() property:valuePromise():andThen(function(value) print(value) --&gt; 2 end) property:set(2) valuePredicate can also be passed, which allows you to filter out values. If it returns exactly true, only then will the promise resolve with the new value. property:valuePromise(function(newValue, oldValue) return newValue == 10 and oldValue == 1 end):andThen(function(newValue) print(newValue) end) property:set(1) property:set(10) --&gt; 10   "},{"title":"forceSet​","type":1,"pageTitle":"Property","url":"/libraries/api/Property#forceSet","content":"Property Instance &lt;/&gt; Property:forceSet(value: any) → () Works the same as Property:set except that values aren't checked for equality, for e.g: local property = Property.new() property.onUpdate:Connect(function(newValue) print(newValue) end) property:forceSet(1) property:forceSet(2) property:forceSet(&quot;a&quot;) --&gt; 1 --&gt; 2 --&gt; &quot;a&quot;   "},{"title":"silentSet​","type":1,"pageTitle":"Property","url":"/libraries/api/Property#silentSet","content":"&lt;/&gt; Property:silentSet(value: any) → () Works almost the same as Property:set, but never fires off the Property.onUpdate signal.  "},{"title":"get​","type":1,"pageTitle":"Property","url":"/libraries/api/Property#get","content":"&lt;/&gt; Property:get() → any Returns a shallow copy of the current value of the property. local property = Property.new() local t = {} property:set(t) print(property:get() == t) --&gt; false   "},{"title":"destroy​","type":1,"pageTitle":"Property","url":"/libraries/api/Property#destroy","content":"&lt;/&gt; Property:destroy() → () Destroys the property and renders it unusable. "},{"title":"serializerUtil","type":0,"sectionRef":"#","url":"/libraries/api/serializerUtil","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"serializerUtil","url":"/libraries/api/serializerUtil#types","content":" "},{"title":"ClassDataType​","type":1,"pageTitle":"serializerUtil","url":"/libraries/api/serializerUtil#ClassDataType","content":"&lt;/&gt; type ClassDataType = { valueType: any, serializer: ( value: any, intermediateSerializedData: {} ) → (), deserializer: (serializedData: {}) → (), }  "},{"title":"Properties​","type":1,"pageTitle":"serializerUtil","url":"/libraries/api/serializerUtil#properties","content":" "},{"title":"customValueType​","type":1,"pageTitle":"serializerUtil","url":"/libraries/api/serializerUtil#customValueType","content":"&lt;/&gt; serializerUtil.customValueType: &quot;serDesCustomValueType&quot; A constant to be used as a key in tables, to represent some type which this utility can easily know about when serializing and deserializing values. local spmeTable = { -- Allow the serializer utility module to know the &quot;type&quot; of this table [serializerUtil.customValueType] = &quot;uniqueType&quot; }  "},{"title":"Functions​","type":1,"pageTitle":"serializerUtil","url":"/libraries/api/serializerUtil#functions","content":" "},{"title":"serialize​","type":1,"pageTitle":"serializerUtil","url":"/libraries/api/serializerUtil#serialize","content":"&lt;/&gt; serializerUtil.serialize(value: any) → () Serializes the given vale, if it can be serialized. If it can't be serialized, then the value it self is returned. local serializedValue = serializerUtil.serializer(150) print(serializedValue) --&gt; 150 (can't serialize a number!) local serializedValue = serializerUtil.serializer(CFrame.new(5,5,5)) print(serializedValue) --&gt; {...} (serialized data)   "},{"title":"deserialize​","type":1,"pageTitle":"serializerUtil","url":"/libraries/api/serializerUtil#deserialize","content":"&lt;/&gt; serializerUtil.deserialize(serializedData: any) → () Deserializes the given serialized value, if it can be deserialized. If it can't be deserialized, then the value it self is returned. local serializedValue = serializerUtil.serializer(CFrame.new(5,5,5)) print(serializerUtil.deserialize(serializedValue)) --&gt; CFrame (5,5,5) print(serializerUtil.deserialize(15)) --&gt; 15 (Can't deserialize a non-serialized value)   "},{"title":"addClassDataType​","type":1,"pageTitle":"serializerUtil","url":"/libraries/api/serializerUtil#addClassDataType","content":"&lt;/&gt; serializerUtil.addClassDataType(classDataType: ClassDataType) → () Adds a class data type to the serializer. A class data type (in the context of this utility) is simply an object which you can use to add your own custom serializers and deserializers. -- In this project X, we have a funny which we would like to serialize -- and deserialize according to how our game is structured; local someUniqueTable = { [serializerUtil.customValueType] = &quot;TheUniqueTable&quot; } serializerUtil.addClassDataType({ valueType = &quot;TheUniqueTable&quot;, serializer = { run = function(uniqueTable, intermediateSerializedData) intermediateSerializedData.component = {1, 2, 3, 4, 5, 6} end, }, deserializer = { run = function(serializedUniqueTable) return serializedUniqueTable.component end, }, }) local serializedTable = serializerUtil.serialize(someUniqueTable) print(serializerUtil.deserialize(serializedTable)) --&gt; {1, 2, 3, 4, 5, 6} Override default data types Currently this utility supports a lot of data types to serialize and serialize - however you can override them too with your own serializers and deserializers for them, for e.g: -- Let's just override the serializer and deserializer for the `Vector3` data type -- in favour of our own: serializerUtil.addClassDataType({ valueType = &quot;Vector3&quot;, serializer = { run = function(vector3, intermediateSerializedData) intermediateSerializedData.components = {vector3.X, vector3.Y, vector3.Z} end, }, deserializer = { run = function(serializedVector3) return Vector3.new(table.unpack(serializedVector3.components)) end, }, }) This gives you flexibility to append your own serializer and deserializer for specific data types as per your game's need!  "},{"title":"addClassDataTypes​","type":1,"pageTitle":"serializerUtil","url":"/libraries/api/serializerUtil#addClassDataTypes","content":"&lt;/&gt; serializerUtil.addClassDataTypes(classDataTypes: {ClassDataType}) → () Shorthand for adding multiple class data types in 1 go. serializerUtil.addClass is called for every class data type in classDataTypes. local classDataTypes = { { valueType = &quot;Vector3&quot;, serializer = { run = function(vector3, intermediateSerializedData) intermediateSerializedData.components = {vector3.X, vector3.Y, vector.Z} end, }, deserializer = { run = function(serializedVector3) return Vector3.new(table.unpack(serializedVector3.components)) end, }, }, { valueType = &quot;Vector2&quot;, serializer = { run = function(vector2, intermediateSerializedData) intermediateSerializedData.components = {vector2.X, vector2.Y} end, }, deserializer = { run = function(serializedVector2) return Vector2.new(table.unpack(serializedVector2.components)) end, }, } } serializerUtil.addClassDataTypes(classDataTypes)   "},{"title":"serializeTableDeep​","type":1,"pageTitle":"serializerUtil","url":"/libraries/api/serializerUtil#serializeTableDeep","content":"&lt;/&gt; serializerUtil.serializeTableDeep(deserializedTable: {[any]: any}) → () Deep serializes all keys and values in the given table via serializerUtil.serialize. local tabl = {bo = Enum.Keycode.A} local serializedTable = serializerUtil.serializeTableDeep(tabl) print(serializedTable) --&gt; {bo: {...}} (serialized)   "},{"title":"deserializeTableDeep​","type":1,"pageTitle":"serializerUtil","url":"/libraries/api/serializerUtil#deserializeTableDeep","content":"&lt;/&gt; serializerUtil.deserializeTableDeep(serializedTable: {[any]: any}) → () Deep - deserializes all keys and values in the given table via serializerUtil.deserialize. local tabl = {bo = Enum.Keycode.A} local serializedTable = serializerUtil.serializeTableDeep(tabl) print(serializerUtil.deserializeTableDeep(serializedTable)) --&gt; {bo: Enum.Keycode.A} (deserialized)  "},{"title":"throttleUtil","type":0,"sectionRef":"#","url":"/libraries/api/throttleUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"throttleUtil","url":"/libraries/api/throttleUtil#functions","content":" "},{"title":"throttle​","type":1,"pageTitle":"throttleUtil","url":"/libraries/api/throttleUtil#throttle","content":"&lt;/&gt; throttleUtil.throttle( seconds: number, descriminator: any ) → ( boolean, number ) Accepts a duration seconds, and returns true if it has been that long since the last time this function returned true. Always returns false the first time it is called. This method returns unique results keyed by script and line number, however you also can pass in some unique value as thedescriminator if you want the method to return unique results keyed by that instead of script and line number. RunService.Heartbeat:Connect(function() if throttleUtil.throttle(1) then print(&quot;Every second, something happens (during a.. heartbeat!)&quot;) end end) Additionally, a second value i.e totalDelta is returned which is basically how much time has passed ever since the last throttle. RunService.Heartbeat:Connect(function() local throttle, totalDelta = throttleUtil.throttle(1) if throttle then print(&quot;Time elapsed since last throttle: &quot;, totalDelta) end end) --&gt; Time elapsed since last throttle: 1.0079841441474855 --&gt; Time elapsed since last throttle: 1.0000211205333471 --&gt; Time elapsed since last throttle: 1.004997929558158 note Throttle data keyed by script and line (or script and descriminator, if descriminator is passed) will be cleared out if it has been more than 1 seconds since the last throttleUtil.throttle call.  "},{"title":"setThrottle​","type":1,"pageTitle":"throttleUtil","url":"/libraries/api/throttleUtil#setThrottle","content":"&lt;/&gt; throttleUtil.setThrottle( descriminator: number, seconds: number ) → () Sets the throttle keyed by descriminator, to seconds. This method is only usually useful in cases where you want to reset throttles. For e.g: local descriminator = &quot;LastInputTypeThrottle&quot; RunService.RenderStepped:Connect(function() if UserInputService:GetLastInputType() == Enum.UserInputType.MouseButton1 then if throttleUtil.throttle(2, descriminator) then print(&quot;GetLastInputType has been Enum.UserInputType.MouseButton1 for 2 seconds now&quot;) end else throttleUtil.setThrottle(descriminator, 0) end end)  "},{"title":"stringUtil","type":0,"sectionRef":"#","url":"/libraries/api/stringUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"stringUtil","url":"/libraries/api/stringUtil#functions","content":" "},{"title":"formatLongString​","type":1,"pageTitle":"stringUtil","url":"/libraries/api/stringUtil#formatLongString","content":"&lt;/&gt; stringUtil.formatLongString(string: string) → () Returns a formatted version of the given string (essentially just add in hiphens). print(stringUtil.formatLongString(&quot;jail in the break&quot;)) --&gt; &quot;jail-in-the-break&quot;  "},{"title":"timeFormatUtil","type":0,"sectionRef":"#","url":"/libraries/api/timeFormatUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"timeFormatUtil","url":"/libraries/api/timeFormatUtil#functions","content":" "},{"title":"format12hFormatTo24hFormat​","type":1,"pageTitle":"timeFormatUtil","url":"/libraries/api/timeFormatUtil#format12hFormatTo24hFormat","content":"&lt;/&gt; timeFormatUtil.format12hFormatTo24hFormat(time: string) → string Formats a time format in 12h format to 24h format. print(timeUtil.format12hFormatTo24hFormat(&quot;1:56 AM&quot;)) --&gt; &quot;01:56&quot;  "},{"title":"rain","type":0,"sectionRef":"#","url":"/libraries/api/rain","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"rain","url":"/libraries/api/rain#types","content":" "},{"title":"CollisonModeFunction​","type":1,"pageTitle":"rain","url":"/libraries/api/rain#CollisonModeFunction","content":"&lt;/&gt; type CollisonModeFunction = ((basePart: BasePart ) → boolean)? A predicate which is called automatically and is passed a base part as the only argument. If the predicate returns a truthy value, then the rain will hit the given base part. If the predicate returns a non truthy value, then the rain will NOT hit the given basepart.   "},{"title":"CollisionMode​","type":1,"pageTitle":"rain","url":"/libraries/api/rain#CollisionMode","content":"&lt;/&gt; interface CollisionMode { callback: 3? blacklist: 2? whitelist: 1 none: 0 }  If rain.CollisionMode.whitelist is passed as the first argument to rain.SetCollisionMode, you can pass in a base part or an array of base parts to be hit by the rain only. If rain.CollisionMode.blacklist is passed as the first argument to rain.SetCollisionMode, you can pass in a base part or an array of base parts to NOT be hit by the rain. If rain.CollisionMode.callback is passed as the first argument to rain.SetCollisionMode, you can pass in a predicate [CollisionModeFunction] that can return a boolean value.  "},{"title":"Properties​","type":1,"pageTitle":"rain","url":"/libraries/api/rain#properties","content":" "},{"title":"enabled​","type":1,"pageTitle":"rain","url":"/libraries/api/rain#enabled","content":"&lt;/&gt; rain.enabled: Property A Property object that contains a value on whether the rain is enabled or not. "},{"title":"Functions​","type":1,"pageTitle":"rain","url":"/libraries/api/rain#functions","content":" "},{"title":"enable​","type":1,"pageTitle":"rain","url":"/libraries/api/rain#enable","content":"&lt;/&gt; rain.enable(tweenInfo: TweenInfo? ) → () Enables the rain.  "},{"title":"disable​","type":1,"pageTitle":"rain","url":"/libraries/api/rain#disable","content":"&lt;/&gt; rain.disable(tweenInfo: TweenInfo? ) → () Disables the rain.  "},{"title":"setColor​","type":1,"pageTitle":"rain","url":"/libraries/api/rain#setColor","content":"&lt;/&gt; rain.setColor( value: Color3 , tweenInfo: TweenInfo? ) → () Sets the rain color.  "},{"title":"color​","type":1,"pageTitle":"rain","url":"/libraries/api/rain#color","content":"&lt;/&gt; rain.color() → () Returns the current rain color value.  "},{"title":"transparency​","type":1,"pageTitle":"rain","url":"/libraries/api/rain#transparency","content":"&lt;/&gt; rain.transparency() → () Returns the current rain transparency value.  "},{"title":"ceiling​","type":1,"pageTitle":"rain","url":"/libraries/api/rain#ceiling","content":"&lt;/&gt; rain.ceiling() → () Returns the current rain ceiling value.  "},{"title":"setTransparency​","type":1,"pageTitle":"rain","url":"/libraries/api/rain#setTransparency","content":"&lt;/&gt; rain.setTransparency(transparency: number) → () Sets the transparency of the rain.  "},{"title":"setTransparency​","type":1,"pageTitle":"rain","url":"/libraries/api/rain#setTransparency","content":"&lt;/&gt; rain.setTransparency(speedRatio: number) → () Sets the speed ratio of the rain.  "},{"title":"setTransparency​","type":1,"pageTitle":"rain","url":"/libraries/api/rain#setTransparency","content":"&lt;/&gt; rain.setTransparency(intensityRatio: number) → () Sets the intensity ratio of the rain.  "},{"title":"setTransparency​","type":1,"pageTitle":"rain","url":"/libraries/api/rain#setTransparency","content":"&lt;/&gt; rain.setTransparency(lightEmission: number) → () Sets the light emission of the rain.  "},{"title":"setTransparency​","type":1,"pageTitle":"rain","url":"/libraries/api/rain#setTransparency","content":"&lt;/&gt; rain.setTransparency(lightInfluence: number) → () Sets the light influence of the rain.  "},{"title":"setVolume​","type":1,"pageTitle":"rain","url":"/libraries/api/rain#setVolume","content":"&lt;/&gt; rain.setVolume( volume: number, tweenInfo: TweenInfo? ) → () Sets the volume of the rain sound.  "},{"title":"setSoundGroup​","type":1,"pageTitle":"rain","url":"/libraries/api/rain#setSoundGroup","content":"&lt;/&gt; rain.setSoundGroup(newSoundGroup: SoundGroup ) → () Sets the sound group of the rain sound by first cloning a copy of it, and then setting the cloned variant's sound group to newSoundGroup, and the old variant is destroyed.  "},{"title":"direction​","type":1,"pageTitle":"rain","url":"/libraries/api/rain#direction","content":"&lt;/&gt; rain.direction() → Vector3  Returns the direction of the rain.  "},{"title":"setDirection​","type":1,"pageTitle":"rain","url":"/libraries/api/rain#setDirection","content":"&lt;/&gt; rain.setDirection( direction: Vector3 , tweenInfo: TweenInfo? ) → () Sets the direction of the rain.  "},{"title":"setCeiling​","type":1,"pageTitle":"rain","url":"/libraries/api/rain#setCeiling","content":"&lt;/&gt; rain.setCeiling(ceiling: number) → () Sets the ceiling of the rain.  "},{"title":"setStraightTexture​","type":1,"pageTitle":"rain","url":"/libraries/api/rain#setStraightTexture","content":"&lt;/&gt; rain.setStraightTexture(asset: string) → () Sets the straight texture of the rain.  "},{"title":"setTopDownTexture​","type":1,"pageTitle":"rain","url":"/libraries/api/rain#setTopDownTexture","content":"&lt;/&gt; rain.setTopDownTexture(asset: string) → () Sets the top down texture of the rain.  "},{"title":"setSplashTexture​","type":1,"pageTitle":"rain","url":"/libraries/api/rain#setSplashTexture","content":"&lt;/&gt; rain.setSplashTexture(asset: string) → () Sets the splash texture of the rain.  "},{"title":"setSoundId​","type":1,"pageTitle":"rain","url":"/libraries/api/rain#setSoundId","content":"&lt;/&gt; rain.setSoundId(asset: string) → () Sets the sound id of the rain sound.  "},{"title":"setConfig​","type":1,"pageTitle":"rain","url":"/libraries/api/rain#setConfig","content":"&lt;/&gt; rain.setConfig(config: { ceiling: number?, intensityRatio: number?, direction: Vector3? , splashTexture: string?, topDownTexture: string?, volume: number?, straightTexture: string?, soundId: string?, transparency: number?, lightEmission: string?, lightInfluence: string?, color: Color3? , speedRatio: number?, collisionMode: string, collisionModeFunction: CollisonModeFunction?, }) → () Sets the rain config.  "},{"title":"setCollisionMode​","type":1,"pageTitle":"rain","url":"/libraries/api/rain#setCollisionMode","content":"&lt;/&gt; rain.setCollisionMode( mode: CollisionMode, param: {Instance } | Instance | CollisonModeFunction ) → () Sets the rain collision mode. -- Example uses: -- 1) rain.setCollisionMode(rain.CollisionMode.callback, function(basePart) return not basePart.CanCollide end) -- 2) rain.setCollisionMode(rain.CollisionMode.whitelist, {Workspace.Baseplate}) -- 3) rain.setCollisionMode(rain.CollisionMode.blacklist, {Workspace.Baseplate})  "},{"title":"viewportFrameUtil","type":0,"sectionRef":"#","url":"/libraries/api/viewportFrameUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"viewportFrameUtil","url":"/libraries/api/viewportFrameUtil#functions","content":" "},{"title":"renderModel​","type":1,"pageTitle":"viewportFrameUtil","url":"/libraries/api/viewportFrameUtil#renderModel","content":"&lt;/&gt; viewportFrameUtil.renderModel( viewportFrame: ViewportFrame , model: Model , data: { cameraFieldOfView: number, rotationSpeed: number? }? ) → () Renders the given model in the viewport frame. Returns a trove. "},{"title":"ViewportModel","type":0,"sectionRef":"#","url":"/libraries/api/ViewportModel","content":"On this page ViewportModel EgoMoose's viewport model class ported to wally.","keywords":""},{"title":"NetworkServer","type":0,"sectionRef":"#","url":"/libraries/api/NetworkServer","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"NetworkServer","url":"/libraries/api/NetworkServer#types","content":" "},{"title":"MethodCallInbound​","type":1,"pageTitle":"NetworkServer","url":"/libraries/api/NetworkServer#MethodCallInbound","content":"&lt;/&gt; type MethodCallInbound = ( methodName: string, client: Player , args: {any} ) → boolean   "},{"title":"MethodCallOutbound​","type":1,"pageTitle":"NetworkServer","url":"/libraries/api/NetworkServer#MethodCallOutbound","content":"&lt;/&gt; type MethodCallOutbound = ( methodName: string, client: Player , args: {any}, methodResponse: any ) → any   "},{"title":"ValueDispatch​","type":1,"pageTitle":"NetworkServer","url":"/libraries/api/NetworkServer#ValueDispatch","content":"&lt;/&gt; type ValueDispatch = ( client: Player , value: any ) → any   "},{"title":"DefaultNetworkServerConfig​","type":1,"pageTitle":"NetworkServer","url":"/libraries/api/NetworkServer#DefaultNetworkServerConfig","content":"&lt;/&gt; interface DefaultNetworkServerConfig { automaticArgumentSerializationAndDeserializationEnabled: true promisifyCallbacks: true }   "},{"title":"DefaultNetworkServerMiddleware​","type":1,"pageTitle":"NetworkServer","url":"/libraries/api/NetworkServer#DefaultNetworkServerMiddleware","content":"&lt;/&gt; interface DefaultNetworkServerMiddleware { methodCallInbound: {} methodCallOutbound: {} valueDispatch: {} }   "},{"title":"NetworkServerConfig​","type":1,"pageTitle":"NetworkServer","url":"/libraries/api/NetworkServer#NetworkServerConfig","content":"&lt;/&gt; interface NetworkServerConfig { automaticArgumentSerializationAndDeserializationEnabled: boolean-- determines whether or not values sent to clients by the remote signal be internally serialized/deserialized or not. promisifyCallbacks: boolean-- determines whether or not a promise is returned to the client (resolved with the return values of the callback) whenever they call a serverside exposed callback }  Remote Signal and Remote Property not subject to automatic serialization / deserialization! RemoteSignal and RemoteProperty objects sent across the network by the network object will never be serialized or deserialized, regardless of automaticArgumentSerializationAndDeserializationEnabled. They're handled internally to ensure they are properly replicated across the network. automaticArgumentSerializationAndDeserializationEnabled -&gt; true Arguments and values sent across the network by the network object will be automatically serialized and deserialized respectively, with the help of an internal library, i.e serializerUtil. ::note Serialization and deserialization limitations! While the serializer utility used to accomplish this supports a variety of data types, do keep in mind that not all data types can be supported on the go for serialization and deserialization - check the above hyperlink to the serializer utility on how many data types it supports. :::: See the type of the value of abc being TweenInfo on the client: -- Server local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.Server.new(&quot;TestNetwork&quot;, nil, { automaticArgumentSerializationAndDeserializationEnabled = true }) testNetwork:append(&quot;abc&quot;, TweenInfo.new()) -- By default, TweenInfos -- are not replicated properlty across the network, but watch the magic! testNetwork:dispatch(Workspace) -- Client local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.client.fromParent(&quot;TestNetwork&quot;, Workspace):expect() print(typeof(testNetwork.abc)) --&gt; &quot;TweenInfo&quot; automaticArgumentSerializationAndDeserializationEnabled -&gt; false Arguments and values sent across the network will not be internally serialized and deserialized. Using the same example as above: See the type of the value of abc being table on the client instead of TweenInfo: -- Server local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.Server.new(&quot;TestNetwork&quot;, nil, { automaticArgumentSerializationAndDeserializationEnabled = false }) testNetwork:append(&quot;abc&quot;, TweenInfo.new()) testNetwork:dispatch(Workspace) -- Client local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.client.fromParent(&quot;abc&quot;, Workspace):expect() print(typeof(testNetwork.abc)) --&gt; &quot;table&quot; promisifyCallbacks -&gt; true: Serverside exposed callback called on the client will immediately return a promise which will be resolved with the return values of the callback. -- Server local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.Server.new(&quot;TestNetwork&quot;, nil, { promisifyCallbacks = true }) testNetwork:append(&quot;method&quot;, function() return task.wait(5) end) testNetwork:dispatch(Workspace) -- Client local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.client.fromParent(&quot;abc&quot;, Workspace):expect() testNetwork.method():andThen(function(deltaTime) print(typeof(deltaTime)) --&gt; &quot;number&quot; end) promisifyCallbacks -&gt; false: Serverside exposed callback called on the client will not return a promise and instead will yield the given thread until the callback has returned back to the caller. -- Server local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.Server.new(&quot;TestNetwork&quot;, nil, { promisifyCallbacks = false }) testNetwork:append(&quot;method&quot;, function() return task.wait(5) end) testNetwork:dispatch(Workspace) -- Client local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.client.fromParent(&quot;abc&quot;, Workspace):expect() print(typeof(testNetwork.method())) --&gt; &quot;number&quot; (Thread is yielded for approx 5 seconds)   "},{"title":"NetworkServer​","type":1,"pageTitle":"NetworkServer","url":"/libraries/api/NetworkServer#NetworkServer","content":"&lt;/&gt; type NetworkServer = NetworkServer   "},{"title":"NetworkServerMiddleware​","type":1,"pageTitle":"NetworkServer","url":"/libraries/api/NetworkServer#NetworkServerMiddleware","content":"&lt;/&gt; interface NetworkServerMiddleware { methodCallInbound: MethodCallInbound-- Before a callback runs. methodCallOutbound: MethodCallOutbound-- After a callback has finished running. valueDispatch: ValueDispatch-- Affects the return value of the callbacks (to the clients) after they've run. }  Yielding in middleware callbacks is not allowed Middleware callbacks aren't allowed to yield. If they do so, their thread will be closed viacoroutine.close and an error will be outputted in the console. Yielding, (especially in network-related code) results in weird bugs and behavior which can be hard to track down! methodCallInbound Callbacks in methodCallInbound are called whenever a client tries to call any of the appended methods of the network. The first argument passed to each callback is the name of the method (the client called), and the second argument, i.e the arguments sent by the client, which are packed into an array. local methodCallInboundCallbacks = { function (methodName, client: Player, arguments) print(client:IsA(&quot;Player&quot;)) --&gt; true print(typeof(arguments)) --&gt; &quot;table&quot; end } --- More control If any of the callbacks return an explicit false value, then the method which the client tried to call, will not be called. This is useful as you can implement for e.g, implementing rate limits! Additionally, you can modify the arguments table which will be reflected in the method, for e.g: -- Server local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.Server.new(&quot;TestNetwork&quot;, {methodCallInbound = { function(_, _, arguments) arguments[2] = &quot;test&quot; end }}) testNetwork:append(&quot;method&quot;, function(player, a) print(a) --&gt; &quot;test&quot; (a ought to be 1, but the middleware modified it!) end) testNetwork:dispatch(Workspace) -- Client local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.client.fromParent(&quot;TestNetwork&quot;, Workspace):expect() testNetwork.method(1) methodCallOutbound Callbacks in methodCallOutbound are called whenever a method (appended to the network) is called by the client, and has finished running. The first argument passed to each callback is the name of the method (client called), and the second argument, i.e the arguments sent by the client, which are packed into an array. A third argument i.e methodResponse is passed to each callback as well, which is just the response of the method called. local methodCallOutboundCallbacks = { function (methodName, client: Player, arguments, methodResponse) print(client:IsA(&quot;Player&quot;)) --&gt; true print(typeof(arguments)) --&gt; &quot;table&quot; end } --- Additionally, these callbacks can return a value that overrides the actual result of the method (which will be sent back to the client). For e.g: -- Server: local Workspace = game:GetService(&quot;Workspace&quot;) local middleware = { { function (methodName, arguments, methodResponse) print(methodResponse) --&gt; &quot;this&quot; return 50 end } } local testNetwork = network.Server.new(&quot;TestNetwork&quot;, middleware) testNetwork:append(&quot;someMethod&quot;, function() return &quot;this&quot; end) testNetwork:dispatch(Workspace) -- Client: local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.fromParent(&quot;TestNetwork&quot;, Workspace):expect() print(testNetwork.someMethod()) --&gt; 50 Additionally, if more than 1 callback returns a value, then all those returned values will be packed into an array and then sent back to the client. This is by design, as it isn't ideal to disregard all returned values for just 1. For e.g: -- Server: local Workspace = game:GetService(&quot;Workspace&quot;) local middleware = { { function (methodName, arguments, response) return 1 end, function (methodName, arguments, response) return 2 end, function (methodName, arguments, response) return 3 end } } local testNetwork = network.server.new(&quot;TestNetwork&quot;, middleware) testNetwork:append(&quot;someMethod&quot;, function() return &quot;this&quot; end) testNetwork:dispatch(Workspace) -- Client: local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.client.fromParent(&quot;TestNetwork&quot;, Workspace):expect() print(testNetwork.someMethod()) --&gt; {1, 2, 3} valueDispatch Callbacks in valueDispatch are called whenever the network object replicates a value (specifically a non function and not a remote signal and not a remote property), e.g a table, number, string, etc. The first argument passed to each callback is the client itself whom the value is going to replicate to, and the value. local valueDispatchCallbacks = { function (client, value) --- end, } --- The return value of the callback will be used in favour of the original value. If more than 1 callback returns a value, all of them will be packed into an array and then sent. local Workspace = game:GetService(&quot;Workspace&quot;) -- Server local valueDispatchCallbacks = { function (client, value) return { test = 1 } end, } local testNetwork = network.Server.new(&quot;TestNetwork&quot;, {valueDispatch = valueDispatchCallbacks}) testNetwork:append(&quot;someValue&quot;, 5) testNetwork:dispatch(Workspace) -- Client local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.client.fromParent(&quot;TestNetwork&quot;, Workspace):expect() print(testNetwork.someValue) --&gt; {test = 1} (this thought to be 5, but the middleware returned a table instead) -- Server local Workspace = game:GetService(&quot;Workspace&quot;) local valueDispatchCallbacks = { function (client, value) print(value) --&gt; 5 return 1 end, function (client, value) print(value) --&gt; 5 return 2 end } local testNetwork = network.Server.new(&quot;TestNetwork&quot;, {valueDispatch = valueDispatchCallbacks}) testNetwork:append(&quot;someValue&quot;, 5) testNetwork:dispatch(Workspace) -- Client local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.client.fromParent(&quot;TestNetwork&quot;, Workspace):expect() print(testNetwork.someValue) --&gt; {1, 2} --- More control If any of the callbacks return a nil value, then the value will not be replicated to the client. For e.g: local Workspace = game:GetService(&quot;Workspace&quot;) -- Server local valueDispatchCallbacks = { function (client, value) return nil end, } local testNetwork = network.Server.new(&quot;TestNetwork&quot;, {valueDispatch = valueDispatchCallbacks}) testNetwork:append(&quot;someValue&quot;, 5) testNetwork:dispatch(Workspace) -- Client local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.client.fromParent(&quot;TestNetwork&quot;, Workspace):expect() print(testNetwork.someValue) --&gt; nil (this thought to be 5, but the middleware returned a nil value instead)  "},{"title":"Properties​","type":1,"pageTitle":"NetworkServer","url":"/libraries/api/NetworkServer#properties","content":" "},{"title":"RemoteProperty​","type":1,"pageTitle":"NetworkServer","url":"/libraries/api/NetworkServer#RemoteProperty","content":"Read only &lt;/&gt; NetworkServer.RemoteProperty: RemoteProperty   "},{"title":"RemoteProperty​","type":1,"pageTitle":"NetworkServer","url":"/libraries/api/NetworkServer#RemoteProperty","content":"Read only &lt;/&gt; NetworkServer.RemoteProperty: RemoteProperty  "},{"title":"Functions​","type":1,"pageTitle":"NetworkServer","url":"/libraries/api/NetworkServer#functions","content":" "},{"title":"new​","type":1,"pageTitle":"NetworkServer","url":"/libraries/api/NetworkServer#new","content":"&lt;/&gt; NetworkServer.new( name: string, middleware: NetworkServerMiddleware?, config: NetworkServerConfig? ) → NetworkServer Creates and returns a new network object of name. -- Server: local network = NetworkServer.new(&quot;Test&quot;) network:append(&quot;key&quot;, &quot;some value&quot;) network:dispatch(game:GetService(&quot;ReplicatedStorage&quot;)) -- Client: local network = network.Client.fromParent(&quot;Test&quot;, game:GetService(&quot;ReplicatedStorage&quot;)):expect() print(network.key) --&gt; &quot;some value&quot; If the 2nd parameter middleware is not specified, then it will default to DefaultNetworkServerMiddleware instead. If the 3rd parameter config is not specified, then it will default to DefaultNetworkServerConfig instead. Network object will initially not be accessible to the client! The network object will initially not be accessible to the client. You need to call NetworkServer:dispatch to render the network object accessible to the client!  "},{"title":"fromName​","type":1,"pageTitle":"NetworkServer","url":"/libraries/api/NetworkServer#fromName","content":"&lt;/&gt; NetworkServer.fromName(name: string) → NetworkServer? Returns a network of the given name, if found. -- Script 1: local network = NetworkServer.new(&quot;Test&quot;) network:append(&quot;key&quot;, &quot;some value&quot;) network:dispatch(game:GetService(&quot;ReplicatedStorage&quot;)) -- Script 2: local testNetwork = NetworkServer.fromName(&quot;Test&quot;)   "},{"title":"fromNamePromise​","type":1,"pageTitle":"NetworkServer","url":"/libraries/api/NetworkServer#fromNamePromise","content":"&lt;/&gt; NetworkServer.fromNamePromise(name: string) → NetworkServer? Promisified version of NetworkServer.fromName. -- Script 1: local network = NetworkServer.new(&quot;Test&quot;) network:append(&quot;key&quot;, &quot;some value&quot;) network:dispatch(game:GetService(&quot;ReplicatedStorage&quot;)) -- Script 2: NetworkServer.fromNamePromise(&quot;Test&quot;):andThen(function(testNetwork) print(testNetwork:dispatch()) end)   "},{"title":"is​","type":1,"pageTitle":"NetworkServer","url":"/libraries/api/NetworkServer#is","content":"&lt;/&gt; NetworkServer.is(self: any) → boolean Returns a boolean indicating if self is a network object or not.  "},{"title":"dispatched​","type":1,"pageTitle":"NetworkServer","url":"/libraries/api/NetworkServer#dispatched","content":"&lt;/&gt; NetworkServer:dispatched() → boolean Returns a boolean indicating if the network object is dispatched to the client or not.  "},{"title":"append​","type":1,"pageTitle":"NetworkServer","url":"/libraries/api/NetworkServer#append","content":"&lt;/&gt; NetworkServer:append( key: string, value: any ) → () Appends a key-value pair, key and value, to the network object, so that it is available to the client once the network object is dispatched. For e.g: -- Server local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.Server.new(&quot;TestNetwork&quot;) testNetwork:append(&quot;key&quot;, &quot;the value!&quot;) testNetwork:dispatch(Workspace) -- Client local testNetwork = Network.client.fromParent(&quot;TestNetwork&quot;, Workspace):expect() print(testNetwork.key) --&gt; &quot;the value!&quot; More support You can also append a RemoteSignal and a RemoteProperty as well, they'll be represented as a ClientRemoteSignal and a ClientRemoteProperty to the client respectively! Precaution! If the network object does not have a default middleware (AutomaticArgumentSerializationAndDeserialization specifically) set, then argument limitations will apply, as remote functions are internally used the key-value pairs accessible to the clients. warning This method will error if the network object is dispatched to the client. Always make sure to append keys and values before you dispatch the network object. You can check if a network object is dispatched to the client or not through NetworkServer:dispatched.  "},{"title":"dispatch​","type":1,"pageTitle":"NetworkServer","url":"/libraries/api/NetworkServer#dispatch","content":"&lt;/&gt; NetworkServer:dispatch(parent: Instance ) → () Dispatches the network folder of the network object to parent, rendering the network object accessible to the client now. -- Server local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local Workspace = game:GetService(&quot;Workspace&quot;) local network = require(ReplicatedStorage.Packages.network) local testNetwork = Network.Server.new(&quot;Test&quot;) testNetwork:append(&quot;method&quot;, function(player) return string.format(&quot;hi, %s!&quot;, player.Name) end) -- Dispatch the network to workspace: testNetwork:dispatch(Workspace) -- Client local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.client.fromParent(&quot;Test&quot;, Workspace):expect() print(testNetwork.method()) --&gt; &quot;hi, bubshurb!&quot;   "},{"title":"destroy​","type":1,"pageTitle":"NetworkServer","url":"/libraries/api/NetworkServer#destroy","content":"&lt;/&gt; NetworkServer:destroy() → () Destroys the network object and all appended remote properties &amp; remote signals within the network object, and renders the network object useless. "},{"title":"weldConstraintUtil","type":0,"sectionRef":"#","url":"/libraries/api/weldConstraintUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"weldConstraintUtil","url":"/libraries/api/weldConstraintUtil#functions","content":" "},{"title":"weld​","type":1,"pageTitle":"weldConstraintUtil","url":"/libraries/api/weldConstraintUtil#weld","content":"&lt;/&gt; weldConstraintUtil.weld( basePart: BasePart , target: BasePart ) → () Welds the given basepart to the target basepart. "},{"title":"soundUtil","type":0,"sectionRef":"#","url":"/libraries/api/soundUtil","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"soundUtil","url":"/libraries/api/soundUtil#properties","content":" "},{"title":"onSoundInstanceCleanup​","type":1,"pageTitle":"soundUtil","url":"/libraries/api/soundUtil#onSoundInstanceCleanup","content":"Read only Signal &lt;/&gt; soundUtil.onSoundInstanceCleanup: Signal&lt;soundInstance: Sound &gt; A signal which is fired whenever a sound instance is cleaned up. soundUtil.onSoundInstanceCleanup:Connect(function(soundInstance: Sound) warn(soundInstance, &quot; cleaned up&quot;) end) note This signal will only fire under the following circumstances: A sound instance played through this utility was destroyed (through :Destroy). "},{"title":"Functions​","type":1,"pageTitle":"soundUtil","url":"/libraries/api/soundUtil#functions","content":" "},{"title":"playingSoundInstances​","type":1,"pageTitle":"soundUtil","url":"/libraries/api/soundUtil#playingSoundInstances","content":"&lt;/&gt; soundUtil.playingSoundInstances() → {Sound } Returns an array of all sound instances that are currently playing.  "},{"title":"stopAllSoundsOfSoundId​","type":1,"pageTitle":"soundUtil","url":"/libraries/api/soundUtil#stopAllSoundsOfSoundId","content":"&lt;/&gt; soundUtil.stopAllSoundsOfSoundId(soundId: string) → () Stops all playing sounds which have a SoundId of soundId, via soundUtil.stopSound.  "},{"title":"playSoundCloneAndCleanup​","type":1,"pageTitle":"soundUtil","url":"/libraries/api/soundUtil#playSoundCloneAndCleanup","content":"&lt;/&gt; soundUtil.playSoundCloneAndCleanup(sound: Sound ) → Sound  Plays a cloned version of the sound and destroys it when it has ended.  "},{"title":"stopAll​","type":1,"pageTitle":"soundUtil","url":"/libraries/api/soundUtil#stopAll","content":"&lt;/&gt; soundUtil.stopAll() → () Stops all playing sounds via soundUtil.stopSound.  "},{"title":"playSound​","type":1,"pageTitle":"soundUtil","url":"/libraries/api/soundUtil#playSound","content":"&lt;/&gt; soundUtil.playSound(soundInstance: Sound ) → Sound  Plays the given sound instance, if the sound instance has a heartbeat callback registered for it, then the sound instance will not be played automatically. soundUtil.registerSoundHeartbeatCallback(someSoundInstance, function(soundInstance, deltaTime) if not soundInstance.Playing then soundInstance.Volume = 0 soundInstance:Play() end -- Lerp the volume to 1: soundInstance.Volume += (2 - soundInstance.Volume) * deltaTime end) soundUtil.playSound(someSoundInstance)   "},{"title":"playSound3D​","type":1,"pageTitle":"soundUtil","url":"/libraries/api/soundUtil#playSound3D","content":"&lt;/&gt; soundUtil.playSound3D( soundInstance: Sound , positionOrBasePart: Vector3 | BasePart ) → Sound  Plays the given sound at the specified given 3D position or instance. If the sound instance has a heartbeat callback registered for it, then the sound instance will not be played automatically. -- Usecase: lightning bolt sounds! local lightningBoltSound = ... local generatedLightningBoltModel = ... soundUtil.playSound3D(lightningBoltSound, generatedLightningBoltModel.PrimaryPart) note Ideally you should always generally pass in a cloned version of the sound instance so you can reuse it. -- BAD: soundUtil.playSound3D(someStorage.someRandomSound, workspace.Baseplate) soundUtil.playSound3D(someStorage.someRandomSound, workspace.ZombiePart) -- PANIC: someStorage.someRandomSound does not exist anymore! -- GOOD: oundUtil.playSound3D(someStorage.someRandomSound:Clone(), workspace.Baseplate) soundUtil.playSound3D(someStorage.someRandomSound:Clone(), workspace.ZombiePart)   "},{"title":"stopSound​","type":1,"pageTitle":"soundUtil","url":"/libraries/api/soundUtil#stopSound","content":"&lt;/&gt; soundUtil.stopSound(soundInstance: Sound ) → () Stops the given sound instance.  "},{"title":"stopSoundId​","type":1,"pageTitle":"soundUtil","url":"/libraries/api/soundUtil#stopSoundId","content":"&lt;/&gt; soundUtil.stopSoundId(soundId: string) → () Stops the given sound id.  "},{"title":"playSoundId​","type":1,"pageTitle":"soundUtil","url":"/libraries/api/soundUtil#playSoundId","content":"&lt;/&gt; soundUtil.playSoundId(soundId: string) → () Plays the given sound id. soundUtil.registerSoundIdHeartbeatCallback(someSoundId, function(soundId, deltaTime) local soundInstancesOfTheSameSoundId = getSoundInstancesOfSoundId(soundId) -- {...} for _, soundInstance in soundInstancesOfTheSameSoundId do if not soundInstance.Playing then soundInstance.Volume = 0 soundInstance:Play() end -- Lerp the volume to 2: soundInstance.Volume += (2 - soundInstance.Volume) * deltaTime end end) soundUtil.playSoundId(someSoundId) No 3D functionality There is no API support for playing sound ids in 3D due to the estimated API complexity.  "},{"title":"registerSoundInstanceCleanupCallback​","type":1,"pageTitle":"soundUtil","url":"/libraries/api/soundUtil#registerSoundInstanceCleanupCallback","content":"&lt;/&gt; soundUtil.registerSoundInstanceCleanupCallback( soundInstance: Sound , cleanupPredicate: (( soundInstance: Sound , deltaTime: number ) → boolean)? ) → () Registers the given callback as a cleanup callback for the given sound instance. The callback will be called every Heartbeat when the sound is stopped via soundUtil.stopSound, for as long as it doesn't return false (to complete cleanup). local someSoundInstance = ... soundUtil.registerSoundInstanceCleanupCallback(someSoundInstance, function(someSoundInstance, deltaTime) -- Lerp the volume to 0: someSoundInstance.Volume += (0 - someSoundInstance.Volume) * deltaTime if someSoundInstance.Volume &lt; 1e-3 then -- We've fully lerped the volume to 0, let's stop the sound and finish -- up cleanup! someSoundInstance:Stop() return false end return true end) soundUtil.playSound(someSoundInstance) task.wait(2) someSoundUtil.stopSound(someSoundInstance) note The cleanupPredicate will no longer run IF the same sound instance is suddenly played again.  "},{"title":"registerSoundInstanceHeartbeatCallback​","type":1,"pageTitle":"soundUtil","url":"/libraries/api/soundUtil#registerSoundInstanceHeartbeatCallback","content":"&lt;/&gt; soundUtil.registerSoundInstanceHeartbeatCallback( soundInstance: Sound , heartbeatCallback: (( soundInstance: Sound , deltaTime: number ) → ())? ) → () Registers the given callback as a heartbeat callback for the given sound instance. It will be called every Heartbeat for as long as the sound is playing (sound will be in &quot;playing&quot; state if it has been played by soundUtil.playSound and has not finished / stopped yet). soundUtil.registerSoundInstanceHeartbeatCallback(someSoundInstance, function(soundInstance, deltaTime) if not soundInstance.Playing then soundInstance.Volume = 0 soundInstance:Play() end -- Lerp the volume to 2: soundInstance.Volume += (2 - soundInstance.Volume) * deltaTime end) soundUtil.playSound(someSoundInstance)   "},{"title":"registerSoundIdHeartbeatCallback​","type":1,"pageTitle":"soundUtil","url":"/libraries/api/soundUtil#registerSoundIdHeartbeatCallback","content":"&lt;/&gt; soundUtil.registerSoundIdHeartbeatCallback( soundId: string, heartbeatCallback: (( soundId: string, deltaTime: number ) → ())? ) → () Registers the given callback as a heartbeat callback for the given sound id. It will be called every Heartbeat for as long as the sound id is not requested to stop (the sound id will be in &quot;playing&quot; state if it has been played by soundUtil.playSoundId). soundUtil.registerSoundIdHeartbeatCallback(someSoundId, function(soundId, deltaTime) local soundInstancesOfTheSameSoundId = getSoundInstancesOfSoundId(soundId) -- {...} for _, soundInstance in soundInstancesOfTheSameSoundId do if not soundInstance.Playing then soundInstance.Volume = 0 soundInstance:Play() end -- Lerp the volume to 2: soundInstance.Volume += (2 - soundInstance.Volume) * deltaTime end end) soundUtil.playSoundId(someSoundId)   "},{"title":"registerSoundIdCleanupCallback​","type":1,"pageTitle":"soundUtil","url":"/libraries/api/soundUtil#registerSoundIdCleanupCallback","content":"&lt;/&gt; soundUtil.registerSoundIdCleanupCallback( soundId: string, cleanupPredicate: (( soundId: string, deltaTime: number ) → boolean)? ) → () Registers the given callback as a cleanup callback for the given sound id. The callback will be called every Heartbeat when the sound id is stopped via soundUtil.stopSoundId, for as long as it doesn't return false (to complete cleanup). soundUtil.registerSoundIdCleanupCallback(someSoundId, function(soundId, deltaTime) local soundInstancesOfTheSameSoundId = getSoundInstancesOfSoundId(soundId) -- {...} local soundInstancesCleanedUpCount = 0 for _, soundInstance in soundInstancesOfTheSameSoundId do -- Lerp the volume to 0: soundInstance.Volume += (0 - someSoundInstance.Volume) * deltaTime if soundInstance.Volume &lt; 1e-3 then cleanedUpAllSoundInstances += 1 -- We've fully lerped the volume to 0, let's stop the sound and finish -- up cleanup! if soundInstance.Playing then soundInstance:Stop() end end end -- Finish up cleanup once we have cleaned up all sound instances return soundInstancesCleanedUpCount &lt; #soundInstancesOfTheSameSoundId end) soundUtil.playSoundId(someSoundId) task.wait(2) someSoundUtil.stopSoundId(someSoundId) note The cleanupPredicate will no longer run IF the given sound id is suddenly played again (and the cleanupPredicate hasn't yet completed). "},{"title":"numberUtil","type":0,"sectionRef":"#","url":"/libraries/api/numberUtil","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#properties","content":" "},{"title":"e​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#e","content":"Read only &lt;/&gt; numberUtil.e: number&lt;2.7182818284590&gt; A mathematical constant, also known as Euler's number.  "},{"title":"phi​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#phi","content":"Read only &lt;/&gt; numberUtil.phi: number&lt;1.618033988749895&gt; A mathematical constant, also known as the golden ratio.  "},{"title":"tau​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#tau","content":"Read only &lt;/&gt; numberUtil.tau: number&lt;6.283185307179586&gt; A mathematical constant, it is the circle constant representing the ratio between circumference and radius.  "},{"title":"g​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#g","content":"Read only &lt;/&gt; numberUtil.g: number&lt;6.6743e-11&gt; A mathematical constant, used in calculating the gravitational attraction between two objects.  "},{"title":"ga​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#ga","content":"Read only &lt;/&gt; numberUtil.ga: number&lt;137.5&gt; A mathematical constant (the golden angle), which is the smaller of the two angles created by sectioning the circumference of a circle.  "},{"title":"ec​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#ec","content":"Read only &lt;/&gt; numberUtil.ec: number&lt;0.577215664901&gt; A mathematical constant (also known as Euler's constant - not to be confused with Euler's number i.e e which approximately equals to 2.718). "},{"title":"Functions​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#functions","content":" "},{"title":"average​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#average","content":"&lt;/&gt; numberUtil.average( sum: number, ...: number ) → number Returns the average of ... numbers against sum. print(numberUtil.average(100, 50, 25)) --&gt; 0.75   "},{"title":"clampTo​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#clampTo","content":"&lt;/&gt; numberUtil.clampTo( number: number, min: number, max: number, clamp: number ) → number Clamps number to clamp, if number is greater than max or lower than min. print(numberUtil.clampTo(1, 2, 5, 150)) --&gt; 150   "},{"title":"close​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#close","content":"&lt;/&gt; numberUtil.close( number: number, to: number, eplison: number? ) → boolean Returns a boolean indicating if the difference between number and to is lower than or equal to eplsion. print(numberUtil.close(0.1 + 0.2, 0.3)) --&gt; true print(numberUtil.close(0.1 + 0.2, 0.3, 0)) --&gt; false If eplison is not specified, then it will default to 1e-2.  "},{"title":"comb​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#comb","content":"&lt;/&gt; numberUtil.comb( number: number, k: number ) → number Returns the number of ways picking k unordered outcomes from number possibilities, without repetition. note If the value of k is greater than number, then the method will return 0. print(numberUtil.comb(2, 1)) --&gt; 2   "},{"title":"commas​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#commas","content":"&lt;/&gt; numberUtil.commas(target: number) → string Returns a string formatted with commas. print(numberUtil.commas(15000)) --&gt; 15,000   "},{"title":"cosec​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#cosec","content":"&lt;/&gt; numberUtil.cosec(number: number) → number Returns the reciprocal of math.sign(number). print(numberUtil.cosec(1)) --&gt; 1.1883951057781212   "},{"title":"cotan​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#cotan","content":"&lt;/&gt; numberUtil.cotan(number: number) → number A trigonometric function that in a right-angled triangle is the ratio of the length of the adjacent side to that of the opposite side; the reciprocal of tangent. print(numberUtil.cotan(1)) --&gt; 0.6420926159343306   "},{"title":"cubicBezier​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#cubicBezier","content":"&lt;/&gt; numberUtil.cubicBezier( t: number, p0: number, p1: number, p2: number, p3: number ) → number Returns the cubic bezier from the arguments. print(cubicBezier(2, 0.15, 0, 0.1, 0)) --&gt; -1.35   "},{"title":"exponentialLerp​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#exponentialLerp","content":"&lt;/&gt; numberUtil.exponentialLerp( number: number, goal: number, alpha: number ) → number Exponentially lerps number to goal, with alpha being the multiplier. print(numberUtil.exponentialLerp(1, 5, 3)) --&gt; 125   "},{"title":"factorial​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#factorial","content":"&lt;/&gt; numberUtil.factorial(number: number) → number Returns the factorial of number. print(numberUtil.factorial(3)) --&gt; 6   "},{"title":"factors​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#factors","content":"&lt;/&gt; numberUtil.factors(number: number) → {number} Returns an array of all factors of number. print(numberUtil.factors(2)) --&gt; {1, 2}   "},{"title":"hoursToMinutes​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#hoursToMinutes","content":"&lt;/&gt; numberUtil.hoursToMinutes(hours: number) → number Returns a number which is hours converted to minutes. print(numberUtil.hoursToMinutes(1)) --&gt; 60   "},{"title":"inverseLerp​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#inverseLerp","content":"&lt;/&gt; numberUtil.inverseLerp( min: number, max: number, alpha: number ) → number Inverse lerp is the inverse operation of the lerp node. It can be used to determine what the input to a lerp was based on its output. print(numberUtil.inverseLerp(2, 5, 0.7)) --&gt; -0.43333333333333335   "},{"title":"lerp​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#lerp","content":"&lt;/&gt; numberUtil.lerp( number: number, goal: number, alpha: number ) → number Interpolates number to goal, with alpha being the multiplier. print(numberUtil.lerp(2, 5, 0.7)) --&gt; 4.1   "},{"title":"logarithmicLerp​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#logarithmicLerp","content":"&lt;/&gt; numberUtil.logarithmicLerp( number: number, goal: number, alpha: number ) → number Logarithmicly lerps number to goal, with alpha being the multiplier. print(numberUtil.logarithmicLerp(1, 2, 3)) --&gt; 0.125   "},{"title":"map​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#map","content":"&lt;/&gt; numberUtil.map( number: number, inMin: number, inMax: number, outMin: number, outMax: number ) → number Maps number between inMin and inMax, and outMin and outMax. print(numberUtil.map(1,2,3,4,5)) --&gt; 3   "},{"title":"max​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#max","content":"&lt;/&gt; numberUtil.max(...: number) → number Returns the maximum value. print(numberUtil.max(10,9,8,7,6,5,4,3,2,1)) --&gt; 10   "},{"title":"mean​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#mean","content":"&lt;/&gt; numberUtil.mean(...: number) → number Returns the mean of the set of numbers .... print(numberUtil.mode(1, 2, 4)) --&gt; 2.3   "},{"title":"median​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#median","content":"&lt;/&gt; numberUtil.median(...: number) → number Returns the median of the set of numbers .... print(numberUtil.median(2, 2)) --&gt; 4   "},{"title":"min​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#min","content":"&lt;/&gt; numberUtil.min(...: number) → number Returns the minimum value. print(numberUtil.min(10,9,8,7,6,5,4,3,2,1)) --&gt; 1   "},{"title":"minutesToHours​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#minutesToHours","content":"&lt;/&gt; numberUtil.minutesToHours(minutes: number) → number Returns a number which is minutes converted to hours. print(numberUtil.minutesToHours(60)) --&gt; 1   "},{"title":"minutesToSeconds​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#minutesToSeconds","content":"&lt;/&gt; numberUtil.minutesToSeconds(minutes: number) → number Returns a number which is minutes converted to seconds. print(numberUtil.minutesToSeconds(1)) --&gt; 60   "},{"title":"mode​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#mode","content":"&lt;/&gt; numberUtil.mode(...: number) → number? From a set of numbers ..., returns the number which is the most frequent. print(numberUtil.mode(1, 2, 3, 3)) --&gt; 3 print(numberUtil.mode(1, 2, 3)) --&gt; nil (no numbers repeat)   "},{"title":"nan​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#nan","content":"&lt;/&gt; numberUtil.nan(number: number) → boolean Returns a boolean indicating if number is NaN (Not A Number). print(numberUtil.nan(0 / 0)) --&gt; true   "},{"title":"quadraticBezier​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#quadraticBezier","content":"&lt;/&gt; numberUtil.quadraticBezier( t: number, p0: number, p1: number, p2: number ) → number Returns the quadratic bezier from the arguments. print(numberUtil.quadraticBezier(0, 0.5, 3, 5)) --&gt; 0.5   "},{"title":"quadraticLerp​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#quadraticLerp","content":"&lt;/&gt; numberUtil.quadraticLerp( number: number, goal: number, alpha: number ) → number Quadraticly interpolates number to goal, with alpha being the multiplier. print(numberUtil.quadraticLerp(2, 5, 0.7)) --&gt; 4.1   "},{"title":"root​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#root","content":"&lt;/&gt; numberUtil.root( number: number, root: number ) → number Returns the root of number. print(numberUtil.root(2, 3)) --&gt; 1.2599210498948732 (same as cube root of 2) print(numberUtil.root(2, 2)) --&gt; 1.4142135623730951 (same as square root of 2)   "},{"title":"secant​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#secant","content":"&lt;/&gt; numberUtil.secant(number: number) → number The ratio of the hypotenuse to the shorter side adjacent to an acute angle (in a right-angled triangle); the reciprocal of a cosine. print(numberUtil.secant(1)) --&gt; 1.8508157176809255   "},{"title":"secondsToDays​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#secondsToDays","content":"&lt;/&gt; numberUtil.secondsToDays(seconds: number) → number Returns a number which is seconds converted to days. print(numberUtil.secondsToDays(86400)) --&gt; 1   "},{"title":"secondsToHours​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#secondsToHours","content":"&lt;/&gt; numberUtil.secondsToHours(seconds: number) → number Returns a number which is seconds converted to hours. print(numberUtil.secondsToHours(3600)) --&gt; 1   "},{"title":"secondsToMinutes​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#secondsToMinutes","content":"&lt;/&gt; numberUtil.secondsToMinutes(seconds: number) → number Returns a number which is seconds converted to minutes. print(numberUtil.secondsToMinutes(60)) --&gt; 1   "},{"title":"sphericalLerp​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#sphericalLerp","content":"&lt;/&gt; numberUtil.sphericalLerp( t: number, w0: number, x0: number, y0: number, z0: number, w1: number, x1: number, y1: number, z1: number, d: number ) → number Returns a result on based on spherical linear interpolation. print(numberUtil.sphericalLerp(1, 1, 1, 1, 1, 1, 1, 1, 1, 1)) --&gt; 2.3   "},{"title":"suffix​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#suffix","content":"&lt;/&gt; numberUtil.suffix(number: number) → string Return a string as the formatted version of number. Cannot format extremely large numbers This method will struggle to format numbers larger than approximately 10^68. print(numberUtil.suffix(10^70)) --&gt; 10 (no formatting...) print(numberUtil.suffix(1650)) --&gt; &quot;1.65K&quot; Additionally, if number is lower than 1, then this method will just return number (stringified).  "},{"title":"to12H​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#to12H","content":"&lt;/&gt; numberUtil.to12H(hour: number) → () Returns the given hour formatted to the 12 hour clock. print(numberUtil.to12H(24)) --&gt; 12 print(numberUtil.to12H(17)) --&gt; 5   "},{"title":"to24H​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#to24H","content":"&lt;/&gt; numberUtil.to24H( hour: number, preset: &quot;am&quot; | &quot;pm&quot; ) → number Returns the given hour formatted to the 12 hour clock. print(numberUtil.to24H(12, &quot;am&quot;)) --&gt; 0 print(numberUtil.to24H(5, &quot;pm&quot;)) --&gt; 17 print(numberUtil.to24H(12, &quot;pm&quot;)) --&gt; 12 print(numberUtil.to24H(11, &quot;pm&quot;)) --&gt; 23 print(numberUtil.to24H(11, &quot;am&quot;)) --&gt; 11   "},{"title":"toHM​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#toHM","content":"&lt;/&gt; numberUtil.toHM(number: number) → string Returns a string which is just number formatted to the HM (Hour, Minutes) format. print(numberUtil.toHM(2 * 3600)) --&gt; 02:00   "},{"title":"toHMS​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#toHMS","content":"&lt;/&gt; numberUtil.toHMS(number: number) → string Returns a string which is just number formatted to the HMS (Hour, Minutes, Seconds) format. print(numberUtil.toHMS(21600)) --&gt; 06:00:00   "},{"title":"toMS​","type":1,"pageTitle":"numberUtil","url":"/libraries/api/numberUtil#toMS","content":"&lt;/&gt; numberUtil.toMS(number: number) → string Returns a string which is just number formatted to the MS (Minutes, Seconds) format. print(numberUtil.toMS(21600)) --&gt; 10:00  "},{"title":"swappableUIUtil","type":0,"sectionRef":"#","url":"/libraries/api/swappableUIUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"swappableUIUtil","url":"/libraries/api/swappableUIUtil#functions","content":" "},{"title":"swappable​","type":1,"pageTitle":"swappableUIUtil","url":"/libraries/api/swappableUIUtil#swappable","content":"&lt;/&gt; swappableUIUtil.swappable( targetGuiObjects: {GuiObject }, userSwappingObserver: (( input: InputObject , inputWasProcessed: boolean, guiObjectSelectedForSwapping: GuiObject ) → ())?, userSwappedObserver: (( input: InputObject , inputWasProcessed: boolean, guiObject: GuiObject , guiObjectSelectedForSwapping: GuiObject ) → ())?, userSwapValidator: (( guiObject: GuiObject , guiObjectSelectedForSwapping: GuiObject ) → ( boolean?, GuiObject? , GuiObject? ))? ) → () Sets up events for swappable gui object dragging where gui object swap their positions. This method does not actually change the positions of the gui objects, but rather their layout orders, so this method assumes that the gui objects are constrained by aUIListLayout. Returns a trove object and a callback for updating targetGuiObjects. "},{"title":"waitForUtil","type":0,"sectionRef":"#","url":"/libraries/api/waitForUtil","content":"On this page waitForUtil An utility module for WaitFor. waitForUtil.custom.class(Workspace, &quot;TextLabel&quot;):andThen(function(textLabel: TextLabel) ... end) ","keywords":""},{"title":"Installation","type":0,"sectionRef":"#","url":"/libraries/docs/intro","content":"","keywords":""},{"title":"Wally Setup​","type":1,"pageTitle":"Installation","url":"/libraries/docs/intro#wally-setup","content":"Once Wally is installed, run wally init on your project directory, and then add the various open-sourced modules that you need, as wally dependencies. For e.g, the following may be a wally.toml file for a project that includes a number wally package: [package] name = &quot;bubshurb/project&quot; version = &quot;1.0.0&quot; registry = &quot;https://github.com/UpliftGames/wally-index&quot; realm = &quot;shared&quot; [dependencies] numberUtil = &quot;bubshurb/numberUtil@1.1.0&quot;  Now, to install these dependencies, run wally install within your project. Wally will then create a package folder in your directory with the installed dependencies. Then use Rojo to sync in the package folder to Studio. "},{"title":"Usage Example​","type":1,"pageTitle":"Installation","url":"/libraries/docs/intro#usage-example","content":"Once the above necessary steps are completed, the installed wally dependencies can now be used in code, e.g: local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local numberUtil = require(ReplicatedStorage.Packages.numberUtil) print(numberUtil.factors(2)) --&gt; {1, 2}  "},{"title":"ZonePlus","type":0,"sectionRef":"#","url":"/libraries/api/ZonePlus","content":"On this page ZonePlus ZonePlus by 1ForeverHD, ported to wally.","keywords":""},{"title":"toolUtil","type":0,"sectionRef":"#","url":"/libraries/api/toolUtil","content":"","keywords":""},{"title":"Functions​","type":1,"pageTitle":"toolUtil","url":"/libraries/api/toolUtil#functions","content":" "},{"title":"toolOwnerInstance​","type":1,"pageTitle":"toolUtil","url":"/libraries/api/toolUtil#toolOwnerInstance","content":"&lt;/&gt; toolUtil.toolOwnerInstance(tool: Tool ) → Player?  Returns the owner instance of the given tool, if found.  "},{"title":"tryPlaceToolInBackpackAndEquip​","type":1,"pageTitle":"toolUtil","url":"/libraries/api/toolUtil#tryPlaceToolInBackpackAndEquip","content":"&lt;/&gt; toolUtil.tryPlaceToolInBackpackAndEquip( player: Player , tool: Tool ) → () Places the given tool in the player's backpack and tries to equips it on the humanoid.  "},{"title":"playerToolCountPredicate​","type":1,"pageTitle":"toolUtil","url":"/libraries/api/toolUtil#playerToolCountPredicate","content":"&lt;/&gt; toolUtil.playerToolCountPredicate( player: Player , predicate: (tool: Tool ) → boolean ) → () Returns the player tool count. predicate is called on every tool owned by the player, and\\ each time it returns true, the tool count is incremented by 1.  "},{"title":"playerTools​","type":1,"pageTitle":"toolUtil","url":"/libraries/api/toolUtil#playerTools","content":"&lt;/&gt; toolUtil.playerTools(player: Player ) → () Returns an array of all player tools - equipped and enequipped.  "},{"title":"currentEquippedTool​","type":1,"pageTitle":"toolUtil","url":"/libraries/api/toolUtil#currentEquippedTool","content":"&lt;/&gt; toolUtil.currentEquippedTool(player: Player ) → () Returns the current equipped tool by the player.  "},{"title":"observePlayerForToolsEquippedAndEnequipped​","type":1,"pageTitle":"toolUtil","url":"/libraries/api/toolUtil#observePlayerForToolsEquippedAndEnequipped","content":"&lt;/&gt; toolUtil.observePlayerForToolsEquippedAndEnequipped( player: Player , observerForToolEquipped: (( newToolEquipped: Tool , oldToolEquipped: Tool? ) → ())?, observerForToolEnequipped: (( newToolUnequipped: Tool , oldToolUnequipped: Tool? ) → ())? ) → () Observes the player for any new tools equipped or unequipped. Also captures all the initial tool equipped. toolUtil.observePlayerForEquippedTool(player, function(newToolEquipped, oldToolEquipped) end, function(newToolUnequipped, oldToolUnEquipped) end)   "},{"title":"observePlayerBackpackForTools​","type":1,"pageTitle":"toolUtil","url":"/libraries/api/toolUtil#observePlayerBackpackForTools","content":"&lt;/&gt; toolUtil.observePlayerBackpackForTools( player: Player , observerForToolAdded: (( newToolAdded: Tool , oldToolAdded: Tool? ) → ())?, observerForToolRemoved: (( newToolRemoved: Tool , oldToolRemoved: Tool? ) → ())? ) → () Observes the player's backpack for any new tools added or removed. Also captures all initial tools in the player backpack. toolUtil.observePlayerBackpackForTools(player, function(newToolAdded, oldToolAdded) end, function(newToolRemoved, oldToolRemoved) end)   "},{"title":"observePlayerForToolOwnership​","type":1,"pageTitle":"toolUtil","url":"/libraries/api/toolUtil#observePlayerForToolOwnership","content":"&lt;/&gt; toolUtil.observePlayerForToolOwnership( player: Player , observerForToolOwnershipGranted: (( newTool: Tool , oldTool: Tool? ) → ())?, observerForToolOwnershipRemoved: (( newTool: Tool , oldTool: Tool? ) → ())? ) → () Observes the player's backpack and character for any new tools added or removed. toolUtil.observePlayerForToolOwnership(player, function(newToolOwnershipGranted, oldToolOwnershipGranted) end, function(newToolOwnershipRemoved, oldToolOwnershipRemoved) end)  "},{"title":"windLines","type":0,"sectionRef":"#","url":"/libraries/api/windLines","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"windLines","url":"/libraries/api/windLines#types","content":" "},{"title":"WindLinesConfig​","type":1,"pageTitle":"windLines","url":"/libraries/api/windLines#WindLinesConfig","content":"&lt;/&gt; interface WindLinesConfig { lifetime: number?-- The life time of wind lines. direction: Vector3? -- The direction of wind lines. speed: number?-- The speed at which wind lines move. spawnRate: number?-- The rate at which wind lines are created. raycastParams: RaycastParams?-- A RaycastParams object, to be used in determining if the player is under a roof or not. } This is a config template, none of these members are required in the config table when configuring windLines through windLines.setConfig, however the config table must not be empty!  "},{"title":"DefaultWindLinesConfig​","type":1,"pageTitle":"windLines","url":"/libraries/api/windLines#DefaultWindLinesConfig","content":"&lt;/&gt; interface DefaultWindLinesConfig { lifetime: 3 direction: Vector3.new(1,0,0) speed: 6 spawnRate: 25 raycastParams: nil } This is the default config template that windLines initially uses. You can configure windLines through windLines.setConfig. "},{"title":"Properties​","type":1,"pageTitle":"windLines","url":"/libraries/api/windLines#properties","content":" "},{"title":"onEffectStarted​","type":1,"pageTitle":"windLines","url":"/libraries/api/windLines#onEffectStarted","content":"Signal Read only &lt;/&gt; windLines.onEffectStarted: Signal&lt;&gt; A signal which is fired whenever the wind lines effect starts.  "},{"title":"onEffectStopped​","type":1,"pageTitle":"windLines","url":"/libraries/api/windLines#onEffectStopped","content":"Signal Read only &lt;/&gt; windLines.onEffectStopped: Signal&lt;&gt; A signal which is fired whenever the wind lines effect stops. "},{"title":"Functions​","type":1,"pageTitle":"windLines","url":"/libraries/api/windLines#functions","content":" "},{"title":"effectStarted​","type":1,"pageTitle":"windLines","url":"/libraries/api/windLines#effectStarted","content":"&lt;/&gt; windLines.effectStarted() → boolean Returns a boolean indicating if the wind lines effect is started.  "},{"title":"started​","type":1,"pageTitle":"windLines","url":"/libraries/api/windLines#started","content":"&lt;/&gt; windLines.started() → boolean Returns a boolean indicating if windLines is started through windLines.start.  "},{"title":"setConfig​","type":1,"pageTitle":"windLines","url":"/libraries/api/windLines#setConfig","content":"&lt;/&gt; windLines.setConfig(newConfig: WindLinesConfig) → () Sets the current config of windLines to newConfig, so that this new config will be used for wind line effects.  "},{"title":"start​","type":1,"pageTitle":"windLines","url":"/libraries/api/windLines#start","content":"&lt;/&gt; windLines.start() → () Starts up the wind lines effect. Custom behavior If the player is standing under a roof, then the wind lines effect will be stopped for realism purposes and this behavior cannot be toggled. However, you can adjust this behavior through windLines.setConfig through the RaycastParams member, since ray casting is used in determining if the player is standing under a roof. For e.g, the following config does not consider descendants in the filteredPartsFolder folder as roofs, so if a player stands under them, the wind lines effect will not be stopped: local Workspace = game:GetService(&quot;Workspace&quot;) local filteredPartsFolder = Workspace.SomeFolder local raycastParams = RaycastParams.new() raycastParams.FilterDescendantsInstances = {filteredPartsFolder} windLines.setConfig({raycastParams = raycastParams}) windLines.start()   "},{"title":"stop​","type":1,"pageTitle":"windLines","url":"/libraries/api/windLines#stop","content":"&lt;/&gt; windLines.stop() → () Stops the wind lines effect. "},{"title":"RemoteProperty","type":0,"sectionRef":"#","url":"/libraries/api/RemoteProperty","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"RemoteProperty","url":"/libraries/api/RemoteProperty#types","content":" "},{"title":"DefaultRemotePropertyConfig​","type":1,"pageTitle":"RemoteProperty","url":"/libraries/api/RemoteProperty#DefaultRemotePropertyConfig","content":"&lt;/&gt; interface DefaultRemotePropertyConfig { automaticArgumentSerializationAndDeserializationEnabled: true }   "},{"title":"DefaultRemotePropertyMiddleware​","type":1,"pageTitle":"RemoteProperty","url":"/libraries/api/RemoteProperty#DefaultRemotePropertyMiddleware","content":"&lt;/&gt; interface DefaultRemotePropertyMiddleware { clientSet: {...} clientGet: {} } By default, clientSet contains a function which always returns [RejectClientSetRequest], in order to reject the client's request of setting a value for themselves in the remote property, as this is a security risk, if by default, this behavior is allowed. Additionally, a warn is also produced in the output to let you know of this. So in order to allow clients to request the server to set their value, then you must define a middleware where clientSet contains at least 1 function, for e.g; local remoteProperty = RemoteProperty.new({ clientSet = { function(_, _, valueFromClient) return valueFromClient end } })   "},{"title":"RemotePropertyConfig​","type":1,"pageTitle":"RemoteProperty","url":"/libraries/api/RemoteProperty#RemotePropertyConfig","content":"&lt;/&gt; interface RemotePropertyConfig { automaticArgumentSerializationAndDeserializationEnabled: boolean-- determines whether or not values sent to clients by the remote signal be internally serialized/deserialized or not. }  automaticArgumentSerializationAndDeserializationEnabled -&gt; true Arguments and values sent across the network by the remote property will be automatically serialized and deserialized respectively, with the help of an internal library, i.e serializerUtil. Serialization and deserialization limitations! While the serializer utility used to accomplish this supports a variety of data types, do keep in mind that not all data types can be supported on the go for serialization and deserialization - check the above hyperlink to the serializer utility on how many data types it supports. See the type of the value of the remote property being TweenInfo on the client: -- Server local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.Server.new(&quot;TestNetwork&quot;) local remoteProperty = network.Server.RemoteProperty.new(TweenInfo.new()) testNetwork:append(&quot;remoteProperty&quot;, remoteProperty) testNetwork:dispatch(Workspace) -- Client local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.client.fromParent(&quot;TestNetwork&quot;, Workspace):expect() print(typeof(testNetwork.remoteProperty:get())) --&gt; &quot;TweenInfo&quot; automaticArgumentSerializationAndDeserializationEnabled -&gt; false Arguments and values sent across the network will not be internally serialized and deserialized. Using the same example as above: See the type of the value of the remote property being table on the client instead of TweenInfo: -- Server local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.Server.new(&quot;TestNetwork&quot;) local remoteProperty = network.Server.RemoteProperty.new(TweenInfo.new()) testNetwork:append(&quot;remoteProperty&quot;, remoteProperty) testNetwork:dispatch(Workspace) -- Client local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.client.fromParent(&quot;TestNetwork&quot;, Workspace):expect() print(typeof(testNetwork.remoteProperty:get())) --&gt; &quot;table&quot;   "},{"title":"RemoteProperty​","type":1,"pageTitle":"RemoteProperty","url":"/libraries/api/RemoteProperty#RemoteProperty","content":"&lt;/&gt; type RemoteProperty = RemoteProperty&lt;T&gt;   "},{"title":"RemotePropertyOnUpdateCallback​","type":1,"pageTitle":"RemoteProperty","url":"/libraries/api/RemoteProperty#RemotePropertyOnUpdateCallback","content":"&lt;/&gt; type RemotePropertyOnUpdateCallback = ( newValue: any, oldValue: any ) → ()   "},{"title":"RemotePropertyValuePredicate​","type":1,"pageTitle":"RemoteProperty","url":"/libraries/api/RemoteProperty#RemotePropertyValuePredicate","content":"&lt;/&gt; type RemotePropertyValuePredicate = ( newValue: any, oldValue: any ) → boolean   "},{"title":"RemotePropertyMiddleware​","type":1,"pageTitle":"RemoteProperty","url":"/libraries/api/RemoteProperty#RemotePropertyMiddleware","content":"&lt;/&gt; interface RemotePropertyMiddleware { clientSet: {( client: Player , value: any ) → any}?, clientGet: {(client: Player ) → any}?, }  Yielding in middleware callbacks is not allowed Middleware callbacks aren't allowed to yield. If they do so, their thread will be closed viacoroutine.close and an error will be outputted in the console. Yielding, (especially in network-related code) results in weird bugs and behavior which can be hard to track down! clientSet Callbacks in clientSet are called whenever the client tries to set the value of the remote property for themselves specifically. The first argument passed to each callback is a reference to the remote property itself, followed by the client object and the value the client is trying to set. local clientSetCallbacks = { function (remoteProperty, client, value) print(RemoteProperty.is(remoteProperty)) --&gt; true print(client:IsA(&quot;Player&quot;)) --&gt; true end } --- More control A clientSet callback can return a non-nil value, which will then be set as the value for the client in the remote property. This is useful in cases where you want to have more control over what values the client can set for themseves in the remote property. For e.g: -- Server local Workspace = game:GetService(&quot;Workspace&quot;) local testRemoteProperty = network.Server.RemoteProperty.new(50, { clientSet = {function() return &quot;rickrolled&quot; end} }) local testNetwork = network.Server.new(&quot;TestNetwork&quot;) testNetwork:append(&quot;property&quot;, testRemoteProperty) testNetwork:dispatch(Workspace) -- Client local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.client.fromParent(&quot;TestNetwork&quot;, Workspace):expect() testNetwork.property:set(1) print(testNetwork.property.onUpdate:Wait()) --&gt; &quot;rickrolled&quot; (This ought to print 1, but our middleware returned a custom value!) You can also return [RejectClientSetRequest] from a clientSet middleware callback, in order to reject the client's request of setting a value for themselves in the remote property. Additionally, if more than 1 callback returns a value, then all those returned values will be packed into an array and then sent back to the client. This is by design - as it isn't ideal to disregard all returned values for just 1. For e.g: -- Server local Workspace = game:GetService(&quot;Workspace&quot;) local testRemoteProperty = network.Server.RemoteProperty.new(50, { clientSet = { function() return &quot;rickrolled&quot; end, function() return &quot;oof&quot; end, function() return &quot;hello&quot; end } }) local testNetwork = network.Server.new(&quot;TestNetwork&quot;) testNetwork:append(&quot;property&quot;, testRemoteProperty) testNetwork:dispatch(Workspace) -- Client local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.client.fromParent(&quot;TestNetwork&quot;, Workspace):expect() testNetwork.property:set(1) print(testNetwork.property.onUpdate:Wait()) --&gt; {&quot;oofed&quot;, &quot;rickrolled&quot;, &quot;hello&quot;} If any of the clientSet middleware callbacks return [RejectClientSetRequest], then the client's request of setting a value for themselves in the remote property, will be rejected. clientGet Callbacks in clientGet are called whenever the client tries to get the value of the remote property. The first argument passed to each callback is a reference to the remote property itself, which is followed by the client object. local clientGetCallbacks = { function (remoteProperty, client) print(client:IsA(&quot;Player&quot;)) --&gt; true end } --- More control A callback can return a non-nil value, which will then be returned to the client. This is useful in cases where you want to have more control over what values the client can retrieve from the remote property. For e.g: -- Server local Workspace = game:GetService(&quot;Workspace&quot;) local testRemoteProperty = network.Server.RemoteProperty.new(5000, { clientGet = {function() return &quot;rickrolled&quot; end} }) local testNetwork = network.Server.new(&quot;TestNetwork&quot;) testNetwork:append(&quot;property&quot;, testRemoteProperty) testNetwork:dispatch(Workspace) -- Client local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.client.fromParent(&quot;TestNetwork&quot;, Workspace):expect() print(testNetwork.property:get()) --&gt; &quot;rickrolled&quot; (This ought to print 5000, but our middleware returned a custom value!) Additionally, if more than 1 callback returns a value, then all those returned values will be packed into an array and then sent back to the client. This is by design - as it isn't ideal to disregard all returned values for just 1. For e.g: -- Server local Workspace = game:GetService(&quot;Workspace&quot;) local testRemoteProperty = network.Server.RemoteProperty.new(50, { clientGet = { function() return &quot;rickrolled&quot; end, function() return &quot;oof&quot; end, function() return &quot;hello&quot; end } }) local testNetwork = network.Server.new(&quot;TestNetwork&quot;) testNetwork:append(&quot;property&quot;, testRemoteProperty) testNetwork:dispatch(Workspace) -- Client local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.client.fromParent(&quot;TestNetwork&quot;, Workspace):expect() print(testNetwork.property:get()) --&gt; {&quot;oofed&quot;, &quot;rickrolled&quot;, &quot;hello&quot;}   "},{"title":"DefaultRemoteSignalConfig​","type":1,"pageTitle":"RemoteProperty","url":"/libraries/api/RemoteProperty#DefaultRemoteSignalConfig","content":"&lt;/&gt; interface DefaultRemoteSignalConfig { automaticArgumentSerializationAndDeserializationEnabled: true globalRateLimit: 0 useUnreliableRemoteEvent: false }  "},{"title":"Properties​","type":1,"pageTitle":"RemoteProperty","url":"/libraries/api/RemoteProperty#properties","content":" "},{"title":"RejectClientSetRequest​","type":1,"pageTitle":"RemoteProperty","url":"/libraries/api/RemoteProperty#RejectClientSetRequest","content":"Read only &lt;/&gt; RemoteProperty.RejectClientSetRequest: &quot;RejectClientSetRequest&quot; A marker that can be passed from a clientSet middleware callback, to reject a client's request of setting some value (for themselves in the remote property).  "},{"title":"onUpdate​","type":1,"pageTitle":"RemoteProperty","url":"/libraries/api/RemoteProperty#onUpdate","content":"Read only Signal RemoteProperty Instance &lt;/&gt; RemoteProperty.onUpdate: Signal&lt;newValue: any,oldValue: any?&gt; A signal which is fired whenever the value of the remote property is set to a new one. The signal is only passed the new value as the only argument.  "},{"title":"clientValueOnUpdate​","type":1,"pageTitle":"RemoteProperty","url":"/libraries/api/RemoteProperty#clientValueOnUpdate","content":"Read only Signal RemoteProperty Instance &lt;/&gt; RemoteProperty.clientValueOnUpdate: Signal&lt;client: Player, newValue: any,oldValue: any?&gt; A signal which is fired whenever the value of player specifically in the remote property is set to a new one. The signal is passed the player as the first argument, and the new specific value of player set in the remote property, as the second argument. "},{"title":"Functions​","type":1,"pageTitle":"RemoteProperty","url":"/libraries/api/RemoteProperty#functions","content":" "},{"title":"new​","type":1,"pageTitle":"RemoteProperty","url":"/libraries/api/RemoteProperty#new","content":"&lt;/&gt; RemoteProperty.new( initialValue: T, middleware: RemotePropertyMiddleware&lt;T&gt;?, config: RemotePropertyConfig? ) → RemoteProperty&lt;T&gt; Creates and returns a new remote property with the value of initialValue. If the 2nd parameter middleware is not specified, then it will default to DefaultRemotePropertyMiddleware instead. If the 3rd parameter config is not specified, then it will default to DefaultRemotePropertyConfig instead.  "},{"title":"is​","type":1,"pageTitle":"RemoteProperty","url":"/libraries/api/RemoteProperty#is","content":"&lt;/&gt; RemoteProperty.is(self: any) → boolean Returns a boolean indicating if self is a remote property or not.  "},{"title":"get​","type":1,"pageTitle":"RemoteProperty","url":"/libraries/api/RemoteProperty#get","content":"RemoteProperty instance &lt;/&gt; RemoteProperty:get() → any Returns a shallow copy of the current value set for the remote property.  "},{"title":"valuePromise​","type":1,"pageTitle":"RemoteProperty","url":"/libraries/api/RemoteProperty#valuePromise","content":"RemoteProperty instance &lt;/&gt; RemoteProperty:valuePromise(valuePredicate: RemotePropertyValuePredicate?) → Promise&lt;any&gt; Returns a promise which is resolved with a non-nil value of the remote property, given that valuePredicate is not passed as an argument. remoteProperty:valuePromise():andThen(function(value) print(value) end) valuePredicate can also be passed, which allows you to filter out values. If it returns exactly true, only then will the promise resolve with the new value. remoteProperty:valuePromise(function(newValue, oldValue) return newValue == 10 and oldValue == 1 end):andThen(function(value) print(value) end) remoteProperty:set(1) remoteProperty:set(10) --&gt; 10   "},{"title":"setRateLimitForClientSettingValue​","type":1,"pageTitle":"RemoteProperty","url":"/libraries/api/RemoteProperty#setRateLimitForClientSettingValue","content":"RemoteProperty instance &lt;/&gt; RemoteProperty:setRateLimitForClientSettingValue( client: Player , rateLimit: number ) → () Rate limits the given client setting their own value by rateLimit seconds. note This specific rate limit set for this client will be removed once the client leaves the game. -- Server remoteProperty:setRateLimitForClientSettingValue(client, 30) -- 30 seconds -- Client clientRemoteProperty.onUpdate:Connect(function(newValue) print(newValue) end) -- Spam the setting of value for the client, so we ought for the value of the -- client stored in the remote property (finally) to be `100`, but instead -- it will be `1`, as subsequent calls after the first one will be ignored -- due to the rate limit imposed. for index = 1, 100 do clientRemoteProperty:set(index) end --&gt; 1   "},{"title":"setForClients​","type":1,"pageTitle":"RemoteProperty","url":"/libraries/api/RemoteProperty#setForClients","content":"RemoteProperty instance &lt;/&gt; RemoteProperty:setForClients( clients: {Player }, value: any ) → () Calls RemoteProperty:setForClient for all clients in clients.  "},{"title":"setForClient​","type":1,"pageTitle":"RemoteProperty","url":"/libraries/api/RemoteProperty#setForClient","content":"RemoteProperty instance &lt;/&gt; RemoteProperty:setForClient( client: Player , value: any ) → () Sets the value of the remote property for client specifically, to value. This client will now no longer be receiving updates of the value of the remote property, and thus will only be receiving updates of their own specific value set in the remote property. note RemoteProperty:removeForClient will be called for the given client whenever they leave the game, so that this value is cleared out for the player, and thus this helps prevent memory leaks. Precaution! Setting the value for client to nil will not remove the client's value - call RemoteProperty:removeForClient to do that. This method will throw an error if you attempt to set a value for the client who are not present anymore in the server (i.e not a descendant of Players) - this is done to avoid memory leaks.   "},{"title":"removeForClient​","type":1,"pageTitle":"RemoteProperty","url":"/libraries/api/RemoteProperty#removeForClient","content":"RemoteProperty instance &lt;/&gt; RemoteProperty:removeForClient(client: Player ) → () Removes the value stored for client specifically in the remote property. This client will now be informed of the current value of the remote property and will now no longer be receiving updates of their specific value (that was previously set in the remote property, as it has been removed), instead the client will start receiving updates of the value of the remote property itself.  "},{"title":"removeForClients​","type":1,"pageTitle":"RemoteProperty","url":"/libraries/api/RemoteProperty#removeForClients","content":"RemoteProperty instance &lt;/&gt; RemoteProperty:removeForClients(clients: {Player }) → () Iterates through clients and calls RemoteProperty:removeForClient for each client.  "},{"title":"clientHasValueSet​","type":1,"pageTitle":"RemoteProperty","url":"/libraries/api/RemoteProperty#clientHasValueSet","content":"RemoteProperty instance &lt;/&gt; RemoteProperty:clientHasValueSet(client: Player ) → boolean Returns a boolean indicating if there is a specific value stored for client in the remote property.  "},{"title":"clientValue​","type":1,"pageTitle":"RemoteProperty","url":"/libraries/api/RemoteProperty#clientValue","content":"RemoteProperty instance &lt;/&gt; RemoteProperty:clientValue(client: Player ) → any Returns a shallow copy of value stored specifically for client in the remote property.  "},{"title":"clientValuePromise​","type":1,"pageTitle":"RemoteProperty","url":"/libraries/api/RemoteProperty#clientValuePromise","content":"RemoteProperty instance &lt;/&gt; RemoteProperty:clientValuePromise( client: Player , valuePredicate: RemotePropertyValuePredicate? ) → Promise&lt;any&gt; Returns a promise which is resolved with a non-nil value of the value stored for the client in the remote property. remoteProperty:clientValuePromise(client):andThen(function(value) print(value) end) valuePredicate (an optional predicate), allows you to filter out values: remoteProperty:clientValuePromise(client, function(newValue, oldValue) print(newValue, oldValue) return oldValue == 1 end):andThen(function(value) print(value) end) remoteProperty:setForClient(client, 1) remoteProperty:setForClient(client, 2) -- Output: -- 1, nil -- 2, 1 -- 2   "},{"title":"set​","type":1,"pageTitle":"RemoteProperty","url":"/libraries/api/RemoteProperty#set","content":"RemoteProperty instance &lt;/&gt; RemoteProperty:set(value: any) → () Sets the value of the remote property to value. Clients who have a specific value set will not be informed of this new value of this remote property.  "},{"title":"clientValueOnUpdateSignalForClient​","type":1,"pageTitle":"RemoteProperty","url":"/libraries/api/RemoteProperty#clientValueOnUpdateSignalForClient","content":"RemoteProperty instance &lt;/&gt; RemoteProperty:clientValueOnUpdateSignalForClient(client: Player ) → Signal Returns a signal that is fired whenever a value is set for the client, or the client's specific value is updated in the remote property (through RemoteProperty:setForClient). remoteProperty:clientValueOnUpdateSignalForClient(somePlayer):Connect(function(newValue, oldValue) print(newValue, oldValue) end) remoteProperty:setForClient(somePlayer, 1) --&gt; 1, nil   "},{"title":"observeClientValue​","type":1,"pageTitle":"RemoteProperty","url":"/libraries/api/RemoteProperty#observeClientValue","content":"RemoteProperty instance &lt;/&gt; RemoteProperty:observeClientValue( client: Player , callback: RemotePropertyOnUpdateCallback ) → RBXScriptConnection  Observes the value of the given client stored in the remote property. remoteProperty:observeClientValue(somePlayer, function(newValue, oldValue) print(newValue, oldValue) end) remoteProperty:setForClient(somePlayer, 1) --&gt; nil, nil --&gt; 1, nil   "},{"title":"observe​","type":1,"pageTitle":"RemoteProperty","url":"/libraries/api/RemoteProperty#observe","content":"RemoteProperty instance &lt;/&gt; RemoteProperty:observe(callback: RemotePropertyOnUpdateCallback) → RBXScriptConnection  Observes the value of the remote property. local remoteProperty = RemoteProperty.new() remoteProperty:observe(function(newValue, oldValue) print(newValue, oldValue) end) remoteProperty:set(1) --&gt; nil, nil --&gt; 1, nil   "},{"title":"observeClientValues​","type":1,"pageTitle":"RemoteProperty","url":"/libraries/api/RemoteProperty#observeClientValues","content":"RemoteProperty instance &lt;/&gt; RemoteProperty:observeClientValues(observer: ( player: Player , newValue: any, oldValue: any ) → ()) → () → () Observes the values set for clients in the remote property. local remoteProperty = RemoteProperty.new() remoteProperty:observeClientValues(function(client: Player, newValue: any, oldValue: any) end)   "},{"title":"destroy​","type":1,"pageTitle":"RemoteProperty","url":"/libraries/api/RemoteProperty#destroy","content":"RemoteProperty instance &lt;/&gt; RemoteProperty:destroy() → () Destroys the remote property and renders it unusable. All clients who have a specific value set for themselves in the remote property will be removed through RemoteProperty:removeForClient. "},{"title":"RemoteSignal","type":0,"sectionRef":"#","url":"/libraries/api/RemoteSignal","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"RemoteSignal","url":"/libraries/api/RemoteSignal#types","content":" "},{"title":"DefaultRemoteSignalMiddleware​","type":1,"pageTitle":"RemoteSignal","url":"/libraries/api/RemoteSignal#DefaultRemoteSignalMiddleware","content":"&lt;/&gt; interface DefaultRemoteSignalMiddleware { serverEvent: {} }   "},{"title":"RemoteSignal​","type":1,"pageTitle":"RemoteSignal","url":"/libraries/api/RemoteSignal#RemoteSignal","content":"&lt;/&gt; type RemoteSignal = RemoteSignal   "},{"title":"RemoteSignalConnectCallback​","type":1,"pageTitle":"RemoteSignal","url":"/libraries/api/RemoteSignal#RemoteSignalConnectCallback","content":"&lt;/&gt; type RemoteSignalConnectCallback = ( client: Player , ...any ) → ()   "},{"title":"RemoteSignalConfig​","type":1,"pageTitle":"RemoteSignal","url":"/libraries/api/RemoteSignal#RemoteSignalConfig","content":"&lt;/&gt; interface RemoteSignalConfig { useUnreliableRemoteEvent: boolean-- determines whether or not the remote signal will use UnreliableRemoteEvent or RemoteEvent internally. automaticArgumentSerializationAndDeserializationEnabled: boolean-- determines whether or not values sent to clients by the remote signal be internally serialized/deserialized or not. globalRateLimit: number-- (in seconds) will serve as the global rate limit for all players firing to this RemoteSignal. }  automaticArgumentSerializationAndDeserializationEnabled -&gt; true Arguments and values sent across the network by the remote signal will be automatically serialized and deserialized respectively, with the help of an internal library, i.e serializerUtil. Serialization and deserialization limitations While the serializer utility used to accomplish this supports a variety of data types, do keep in mind that not all data types can be supported on the go for serialization and deserialization - check the above hyperlink to the serializer utility on how many data types it supports. See the type of the value sent to the client by the remote signal, being TweenInfo on the client: -- Server local Workspace = game:GetService(&quot;Workspace&quot;) local Players = game:GetService(&quot;Players&quot;) local testNetwork = network.Server.new(&quot;TestNetwork&quot;) local remoteSignal = network.Server.RemoteSignal.new() testNetwork:append(&quot;remoteSignal&quot;, remoteSignal) testNetwork:dispatch(Workspace) remoteSignal:fireClient(Players:GetPlayers()[1] or Players.PlayerAdded:Wait()) -- Client local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.client.fromParent(&quot;TestNetwork&quot;, Workspace):expect() testNetwork.remoteSignal:connect(function(value) print(typeof(value)) --&gt; &quot;TweenInfo&quot; end) automaticArgumentSerializationAndDeserializationEnabled -&gt; false Arguments and values sent across the network by the remote signal will not be internally serialized and deserialized. Using the same example as above: See the type of the value sent to the client by the remote signal, being TweenInfo on the client: -- Server local Workspace = game:GetService(&quot;Workspace&quot;) local Players = game:GetService(&quot;Players&quot;) local testNetwork = network.Server.new(&quot;TestNetwork&quot;) local remoteSignal = network.Server.RemoteSignal.new() testNetwork:append(&quot;remoteSignal&quot;, remoteSignal) testNetwork:dispatch(Workspace) remoteSignal:fireClient(Players:GetPlayers()[1] or Players.PlayerAdded:Wait()) -- Client local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.client.fromParent(&quot;TestNetwork&quot;, Workspace):expect() testNetwork.remoteSignal:connect(function(value) print(typeof(value)) --&gt; &quot;table&quot; end)   "},{"title":"RemoteSignalMiddleware​","type":1,"pageTitle":"RemoteSignal","url":"/libraries/api/RemoteSignal#RemoteSignalMiddleware","content":"&lt;/&gt; interface RemoteSignalMiddleware { serverEvent: {( remoteSignal: RemoteSignal, client: Player , args: {any} ) → any}?, }  Yielding in middleware callbacks is not allowed Middleware callbacks aren't allowed to yield. If they do so, their thread will be closed viacoroutine.close and an error will be outputted in the console. Yielding, (especially in network-related code) results in weird bugs and behavior which can be hard to track down! serverEvent Callbacks in serverEvent are called whenever the client fires off the remote signal. The first argument passed to each callback is a reference to the remote signal itself, which is followed by the client itself, which is followed by an array of arguments fired by the client. local serverEventCallbacks = { function (remoteSignal, client: Player, arguments) print(RemoteSignal.is(remoteSignal)) --&gt; true print(client:IsA(&quot;Player&quot;)) --&gt; true print(typeof(arguments)) --&gt; &quot;table&quot; end } --- More control If any of the callbacks return an explicit false value, then the remote signal will not be fired. For e.g: -- Server local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.Server.new(&quot;TestNetwork&quot;) local testRemoteSignal = network.Server.RemoteSignal.new({ serverEvent = {function() return false end} }) testRemoteSignal:connect(function() print(&quot;Fired&quot;) --&gt; never prints end) testNetwork:append(&quot;signal&quot;, testRemoteSignal) testNetwork:dispatch(Workspace) -- Client local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.client.fromParent(&quot;TestNetwork&quot;, Workspace) print(testNetwork.signal:fireServer()) Additionally, you can modify the arguments table before it is passed to the connected callback, for e.g: -- Server local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.Server.new(&quot;TestNetwork&quot;) local testRemoteSignal = network.Server.RemoteSignal.new({ serverEvent = { function(_, arguments) arguments[2] = 5 arguments[3] = &quot;test&quot; end } }) testRemoteSignal:connect(function(client, a, b) print(a, b) --&gt; 5, &quot;test&quot; (a and b ought to be 1 and 24 respectively, but they were modified through the middleware) end) testNetwork:append(&quot;signal&quot;, testRemoteSignal) testNetwork:dispatch(Workspace) -- Client local Workspace = game:GetService(&quot;Workspace&quot;) local testNetwork = network.client.fromParent(&quot;Test&quot;, Workspace):expect() print(testNetwork.signal:fireServer(1, 24))  "},{"title":"Functions​","type":1,"pageTitle":"RemoteSignal","url":"/libraries/api/RemoteSignal#functions","content":" "},{"title":"new​","type":1,"pageTitle":"RemoteSignal","url":"/libraries/api/RemoteSignal#new","content":"&lt;/&gt; RemoteSignal.new( middleware: RemoteSignalMiddleware?, config: RemoteSignalConfig? ) → RemoteSignal Creates and returns a new remote signal. If the 2nd parameter middleware is not specified, then it will default to DefaultRemoteSignalMiddleware instead. If the 3rd parameter config is not specified, then it will default to DefaultRemoteSignalConfig instead.  "},{"title":"is​","type":1,"pageTitle":"RemoteSignal","url":"/libraries/api/RemoteSignal#is","content":"&lt;/&gt; RemoteSignal.is(self: any) → boolean Returns a boolean indicating if self is a remote signal or not.  "},{"title":"connect​","type":1,"pageTitle":"RemoteSignal","url":"/libraries/api/RemoteSignal#connect","content":"RemoteSignal instance &lt;/&gt; RemoteSignal:connect(callback: RemoteSignalConnectCallback) → RBXScriptConnection  Connects callback to the remote signal so that it is called whenever the client fires the remote signal. Additionally, callback will be passed all the arguments sent by the client. -- Server remoteSignal:connect(function(client, a, b) print(a + b) --&gt; 3 end) -- Client clientRemoteSignal:fireServer(1, 2) Possible Rate Limit It is possible that the client firing to this remote signal is intercepted by a rate-limit, either due to the global rate limit imposed on this remote signal for all players, or a specific-rate limit imposed for this client. local remoteSignal = RemoteSignal.new(nil, 10) -- global rate limit of 10 seconds -- Server remoteSignal:connect(function() print(&quot;Fired&quot;) end) --&gt; &quot;Fired&quot; -- Only printed once! -- Client for _ = 1, 5 do clientRemoteSignal:fireServer() end If you do not desire this behavior, you can do the following: Set a specific rate limit for the client through RemoteSignal:setRateLimitForClient or RemoteSignal:setRateLimitForClients, to 0. Not impose a global rate limit to the remote signal (See RemoteSignalConfig for more info).  "},{"title":"once​","type":1,"pageTitle":"RemoteSignal","url":"/libraries/api/RemoteSignal#once","content":"RemoteSignal instance &lt;/&gt; RemoteSignal:once(callback: RemoteSignalConnectCallback) → RBXScriptConnection  Works almost exactly the same as RemoteSignal:connect, except the connection returned is disconnected immediately upon callback being called.  "},{"title":"wait​","type":1,"pageTitle":"RemoteSignal","url":"/libraries/api/RemoteSignal#wait","content":"RemoteSignal instance &lt;/&gt; RemoteSignal:wait() → ...any Connects callback to the remote signal so that it is called whenever the remote signal is fired off by the client successfully. Additionally, callback will be passed all the arguments sent by the client. -- Server remoteSignal:connect(function(client, a, b) print(a + b) --&gt; 3 end) -- Client clientRemoteSignal:fireServer(1, 2)   "},{"title":"wait​","type":1,"pageTitle":"RemoteSignal","url":"/libraries/api/RemoteSignal#wait","content":"RemoteSignal instance &lt;/&gt; RemoteSignal:wait() → ...any Yields the current thread until the remote signal is successfully fired off by the client. The yielded thread is resumed once the client fires some data to the server successfully, with the arguments sent by the client. -- Server local client, a, b = remoteSignal:wait() print(a + b) --&gt; 3 -- Client clientRemoteSignal:fireServer(1, 2)   "},{"title":"setRateLimitForClient​","type":1,"pageTitle":"RemoteSignal","url":"/libraries/api/RemoteSignal#setRateLimitForClient","content":"RemoteSignal instance &lt;/&gt; RemoteSignal:setRateLimitForClient( client: Player , rateLimit: number ) → () Sets a specific rate limit for the given client. note This specific rate limit set for this client will be removed once the client leaves the game.  "},{"title":"setRateLimitForClients​","type":1,"pageTitle":"RemoteSignal","url":"/libraries/api/RemoteSignal#setRateLimitForClients","content":"RemoteSignal instance &lt;/&gt; RemoteSignal:setRateLimitForClients( clients: {Player }, rateLimit: number ) → () Wrapper for RemoteSignal:setRateLimitForClient for an array of clients.  "},{"title":"removeSpecificRateLimitForClient​","type":1,"pageTitle":"RemoteSignal","url":"/libraries/api/RemoteSignal#removeSpecificRateLimitForClient","content":"RemoteSignal instance &lt;/&gt; RemoteSignal:removeSpecificRateLimitForClient(client: Player ) → () Removes the specific rate limit set for the given client (through RemoteSignal:setRateLimitForClient). Global Rate Limit If the remote signal has a global rate limit set (see RemoteSignal.new's second parameter), then the given client will now be subject to that global rate limit. If you do not desire this behavior and want the rate limit imposation completely lifted for the client, you should set a specific rate limit of 0 for the given client (through RemoteSignal:setRateLimitForClient).  "},{"title":"removeSpecificRateLimitForClients​","type":1,"pageTitle":"RemoteSignal","url":"/libraries/api/RemoteSignal#removeSpecificRateLimitForClients","content":"RemoteSignal instance &lt;/&gt; RemoteSignal:removeSpecificRateLimitForClients(clients: {Player }) → () Wrapper for RemoteSignal:removeSpecificRateLimitForClient for an array of clients.  "},{"title":"fireClient​","type":1,"pageTitle":"RemoteSignal","url":"/libraries/api/RemoteSignal#fireClient","content":"RemoteSignal instance &lt;/&gt; RemoteSignal:fireClient( client: Player , ...: any ) → () Fires the given arguments to client.  "},{"title":"fireAllClients​","type":1,"pageTitle":"RemoteSignal","url":"/libraries/api/RemoteSignal#fireAllClients","content":"RemoteSignal instance &lt;/&gt; RemoteSignal:fireAllClients(...: any) → () Calls RemoteSignal:fireClient for every player in the game, passing in the given arguments along.  "},{"title":"fireClients​","type":1,"pageTitle":"RemoteSignal","url":"/libraries/api/RemoteSignal#fireClients","content":"RemoteSignal instance &lt;/&gt; RemoteSignal:fireClients( clients: {Player }, ...: any ) → () Iterates through clients and calls RemoteSignal:fireClient for each client, passing in the given arguments along.  "},{"title":"fireAllClientsExcept​","type":1,"pageTitle":"RemoteSignal","url":"/libraries/api/RemoteSignal#fireAllClientsExcept","content":"RemoteSignal instance &lt;/&gt; RemoteSignal:fireAllClientsExcept( client: Player , ...: any ) → () Calls RemoteSignal:fireClient for every player in the game, except for client, passing in the given arguments along.  "},{"title":"destroy​","type":1,"pageTitle":"RemoteSignal","url":"/libraries/api/RemoteSignal#destroy","content":"RemoteSignal instance &lt;/&gt; RemoteSignal:destroy() → () Destroys the remote signal and renders it unusable. "}]